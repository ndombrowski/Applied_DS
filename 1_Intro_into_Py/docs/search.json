[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Data Science Course 1",
    "section": "",
    "text": "This course will introduce the learner to the basics of the python programming environment, including fundamental python programming techniques such as lambdas, reading and manipulating csv files, and the numpy library. The course will introduce data manipulation and cleaning techniques using the popular python pandas data science library and introduce the abstraction of the Series and DataFrame as the central data structures for data analysis, along with tutorials on how to use functions such as groupby, merge, and pivot tables effectively. By the end of this course, students will be able to take tabular data, clean it, manipulate it, and run basic inferential statistical analyses."
  },
  {
    "objectID": "code/1_intro.html",
    "href": "code/1_intro.html",
    "title": "2  Introduction into python",
    "section": "",
    "text": "The syntax for writing a function in python. add_numbers is a function that takes two numbers and adds them together.\n\ndef add_numbers(x, y):\n    return x + y\n\nadd_numbers(1,2)\n\n3\n\n\nWe can easily change this to take 3 arguments instead of 2. we can also make the 3rd parameter optional.\nAll of the optional parameters, the ones that you got default values for, need to come at the end of the function declaration. It also means that you can pass an optional parameters as labeled values.\n\ndef add_numbers(x, y, z=None):\n    if z == None:\n        return x + y\n    else:\n        return x + y + z\n\nprint(add_numbers(1,2))\nprint(add_numbers(1,2,3))\n\n3\n6\n\n\nadd_numbers updated to take an optional flag parameter.\n\ndef add_numbers(x, y, z=None, flag=False):\n    if (flag):\n        print('Flag is true!')\n    if (z == None):\n        return x + y\n    else:\n        return x + y + z\n\n\nprint(add_numbers(1, 2, flag=True))\n\nFlag is true!\n3\n\n\nWe can use this for functions to add different modes of operation, i.e. we can add versus subtract:\n\ndef do_math(a, b, kind=None):\n  if (kind=='add'):\n    return a+b\n  else:\n    return a-b\n\ndo_math(1, 2, kind='add')\n\n3\n\n\nWe can also assign function add_numbers to variable a.\n\ndef add_numbers(x, y):\n    return x + y\n\n\na = add_numbers\na(1, 2)\n\n3"
  },
  {
    "objectID": "code/1_intro.html#python-types-and-sequences",
    "href": "code/1_intro.html#python-types-and-sequences",
    "title": "2  Introduction into python",
    "section": "2.2 Python Types and Sequences",
    "text": "2.2 Python Types and Sequences\nWe identify the type of a variable using the type() function:\n\ntype(add_numbers)\n\nfunction\n\n\n\n2.2.1 Tuples\nTuples are an immutable data structure (cannot be altered). We write tuples using parentheses and we can mix types within a tuple.\n\nx = (1, 'a', 2, 'b')\ntype(x)\n\ntuple\n\n\n\n\n2.2.2 Lists\nLists are a mutable data structure. A list is declared using a squared bracket.\n\nx = [1, 'a', 2, 'b']\ntype(x)\n\nlist\n\n\nWe can change the contents of a list, for example using the append function, which appends new items to the end of a list\n\nx.append(3.3)\nx\n\n[1, 'a', 2, 'b', 3.3]\n\n\n\n\n2.2.3 For loops\nBoth list and tuples are iterable types, so we can write loops to go through every value they hold.\n\nfor item in x:\n    print(item)\n\nprint('')\n\n1\na\n2\nb\n3.3\n\n\n\n\n\n2.2.4 Arrays\nLists and tuples can also be accessed as arrays by using the square bracket operator, which is called the indexing operator.\nThe first item of the list starts at position zero and to get the length of the list, we use the built in len function.\n\ni = 0\n\nwhile (i != len(x)):\n    print(x[i])\n    i = i + 1\n\nprint('')\n\n1\na\n2\nb\n3.3\n\n\n\n\n\n2.2.5 Concatenate lists\n\n[1, 2] + [3, 4]\n\n[1, 2, 3, 4]\n\n\n\n\n2.2.6 Repeat values in a list\n\n[1,2] * 3\n\n[1, 2, 1, 2, 1, 2]\n\n\n\n\n2.2.7 The in operator\nWe use the in operator to check if something is inside a list.\n\n1 in [1,2,3]\n\nTrue\n\n\n\n1 in [0,4,5]\n\nFalse\n\n\n\n\n2.2.8 Slicing\nIn Python, the indexing operator allows you to submit multiple values.\nThe first parameter is the starting location, if this is the only element then one item is return from the list.\nThe second parameter is the end of the slice. It’s an exclusive end so if you slice with the first parameter being zero the next parameter being one, then you only get back one item.\n\nx = 'This is a string'\nprint(x[0])  #first character\nprint(x[0:1])  #first character, but we have explicitly set the end character\nprint(x[0:2])  #first two characters\n\nT\nT\nTh\n\n\nOur index values can also be negative to index from the back of the string.\n\nx[-1]\n\n'g'\n\n\n\n#all characters from the 4th last to the second last\nx[-4:-2]\n\n'ri'\n\n\nStart at the first and going until the 3rd:\n\nx[:3]\n\n'Thi'\n\n\nStart with the fourth character and go to the end of the list\n\nx[4:]\n\n' is a string'\n\n\n\n\n2.2.9 Strings\nA lot of the operations we have done before, we can also do on strings\n\nfirstname = 'Christopher'\nlastname = 'Brooks'\n\n#concatenate two strings\nprint(firstname + ' ' + lastname)\n\n#repeat strings\nprint(firstname *2)\n\n#search for strings\nprint('Chris' in firstname)\n\nChristopher Brooks\nChristopherChristopher\nTrue\n\n\nBefore concatenating strings, we have to make sure to convert objects to strings. i.e. this does not work\n'Chris' + 2\nbut this does:\n\n'Chris' + str(2)\n\n'Chris2'\n\n\n\n\n2.2.10 Split\nsplit breaks up a string and returns a list of all the words in a string, or a list split on a specific character.\nBelow, we split up the string based on the presence of a space character resulting in a list of four elements. We can then use an index operator to choose parts of the list:\n\n# [0] selects the first element of the list\nfirstname = 'Christopher Arthur Hansen Brooks'.split(' ')[0]  \n\n# [-1] selects the last element of the list\nlastname = 'Christopher Arthur Hansen Brooks'.split(' ')[-1]  \n\nprint(firstname)\nprint(lastname)\n\nChristopher\nBrooks"
  },
  {
    "objectID": "code/1_intro.html#dictionaries",
    "href": "code/1_intro.html#dictionaries",
    "title": "2  Introduction into python",
    "section": "2.3 Dictionaries",
    "text": "2.3 Dictionaries\nDictionaries are similar to lists and tuples in that they hold a collection of items, but they’re labeled collections which do not have an ordering. This means that for each value you insert into the dictionary, you must also give a key to get that value out. A dictionary is denoted by curly brackets.\nWe indicate each item of the dictionary when creating it using a pair of values separated by colons.\nWe can retrieve a value for a given label using the indexing operator.\n\nx = {'Christopher Brooks': 'brooksch@umich.edu', 'Bill Gates': 'billg@microsoft.com'}\n\n# Retrieve a value by using the indexing operator\nx['Christopher Brooks']  \n\n'brooksch@umich.edu'\n\n\nWe can also add new items to the dictionary:\n\nx['Kevin Thompson'] = None\nx\n\n{'Christopher Brooks': 'brooksch@umich.edu',\n 'Bill Gates': 'billg@microsoft.com',\n 'Kevin Thompson': None}\n\n\n\n#access the values\nx.values()\n\ndict_values(['brooksch@umich.edu', 'billg@microsoft.com', None])\n\n\n\n#access the key:value pairs\nx.items()\n\ndict_items([('Christopher Brooks', 'brooksch@umich.edu'), ('Bill Gates', 'billg@microsoft.com'), ('Kevin Thompson', None)])\n\n\nWe can iterate through the items in a dictionary, i.e. we can iterate over all the keys:\n\nfor name in x:\n    print(x[name])\n\nprint('')\n\nbrooksch@umich.edu\nbillg@microsoft.com\nNone\n\n\n\nIterate over all the values:\n\nfor email in x.values():\n    print(email)\n\nprint('')    \n\nbrooksch@umich.edu\nbillg@microsoft.com\nNone\n\n\n\nWe can also iterate over all the keys and items in a dictionary:\n\nfor name, email in x.items():\n    print(name)\n    print(email)\n\nprint('')\n\nChristopher Brooks\nbrooksch@umich.edu\nBill Gates\nbillg@microsoft.com\nKevin Thompson\nNone\n\n\n\n\n2.3.1 Unpacking\nIn Python you can have a sequence. That’s a list or a tuple of values, and you can unpack those items into different variables through assignment in one statement.\n\nx = ('Christopher', 'Brooks', 'brooksch@umich.edu')\nfname, lname, email = x\n\nprint(fname)\nprint(lname)\nprint(x)\n\nChristopher\nBrooks\n('Christopher', 'Brooks', 'brooksch@umich.edu')\n\n\nMake sure the number of values you are unpacking matches the number of variables being assigned. I.e. the code below would give an error:\nx = ('Christopher', 'Brooks', 'brooksch@umich.edu', 'Ann Arbor')\nfname, lname, email = x"
  },
  {
    "objectID": "code/1_intro.html#python-more-on-strings",
    "href": "code/1_intro.html#python-more-on-strings",
    "title": "2  Introduction into python",
    "section": "2.4 Python More on Strings",
    "text": "2.4 Python More on Strings\nThe Python string formatting mini language allows you to write a string statement indicating placeholders for variables to be evaluated. You then pass these variables in either named or in order arguments, and Python handles the string manipulation for you.\nWe can write a sales statement string which includes these items using curly brackets.\nWe can then call the format method on that string and pass in the values that we want substituted as appropriate.\n\nsales_record = {\n    'price': 3.24,\n    'num_items': 4,\n    'person': 'Chris'}\n\nsales_statement = '{} bought {} item(s) at a price of {} each for a total of {}'\n\nprint(sales_statement.format(sales_record['person'],\nsales_record['num_items'],\nsales_record['price'],\nsales_record['num_items'] * sales_record['price']))\n\nChris bought 4 item(s) at a price of 3.24 each for a total of 12.96"
  },
  {
    "objectID": "code/1_intro.html#reading-and-writing-csv-files",
    "href": "code/1_intro.html#reading-and-writing-csv-files",
    "title": "2  Introduction into python",
    "section": "2.5 Reading and Writing CSV files",
    "text": "2.5 Reading and Writing CSV files\nLet’s import our datafile ../data/mpg.csv, which contains fuel economy data for 234 cars, using the csv module.\n\nmpg : miles per gallon\nclass : car classification\ncty : city mpg\ncyl : # of cylinders\ndispl : engine displacement in liters\ndrv : f = front-wheel drive, r = rear wheel drive, 4 = 4wd\nfl : fuel (e = ethanol E85, d = diesel, r = regular, p = premium, c = CNG)\nhwy : highway mpg\nmanufacturer : automobile manufacturer\nmodel : model of car\ntrans : type of transmission\nyear : model year\n\n\nimport csv\n\n\nwith open('../data/mpg.csv') as csvfile:\n    #read in data as a dictionary\n    mpg = list(csv.DictReader(csvfile))\n\nmpg[:3]\n\n[OrderedDict([('', '1'),\n              ('manufacturer', 'audi'),\n              ('model', 'a4'),\n              ('displ', '1.8'),\n              ('year', '1999'),\n              ('cyl', '4'),\n              ('trans', 'auto(l5)'),\n              ('drv', 'f'),\n              ('cty', '18'),\n              ('hwy', '29'),\n              ('fl', 'p'),\n              ('class', 'compact')]),\n OrderedDict([('', '2'),\n              ('manufacturer', 'audi'),\n              ('model', 'a4'),\n              ('displ', '1.8'),\n              ('year', '1999'),\n              ('cyl', '4'),\n              ('trans', 'manual(m5)'),\n              ('drv', 'f'),\n              ('cty', '21'),\n              ('hwy', '29'),\n              ('fl', 'p'),\n              ('class', 'compact')]),\n OrderedDict([('', '3'),\n              ('manufacturer', 'audi'),\n              ('model', 'a4'),\n              ('displ', '2'),\n              ('year', '2008'),\n              ('cyl', '4'),\n              ('trans', 'manual(m6)'),\n              ('drv', 'f'),\n              ('cty', '20'),\n              ('hwy', '31'),\n              ('fl', 'p'),\n              ('class', 'compact')])]\n\n\n\n#print the length of our list\nlen(mpg)\n\n234\n\n\nThe length of our list is 234, meaning we have a dictionary for each of the 234 cars in the CSV file.\n\n#print column names\nmpg[0].keys()\n\nodict_keys(['', 'manufacturer', 'model', 'displ', 'year', 'cyl', 'trans', 'drv', 'cty', 'hwy', 'fl', 'class'])\n\n\nFind the average cty fuel economy across all cars. All values in the dictionaries are strings, so we need to convert to float.\n\nsum(float(d['cty']) for d in mpg) / len(mpg)\n\n16.858974358974358\n\n\nFind the average city MPG grouped by the number of cylinders a car has.\nWe use set to return the unique values for the number of cylinders the cars in our dataset have.\n\ncylinders = set(d['cyl'] for d in mpg)\ncylinders\n\n{'4', '5', '6', '8'}\n\n\n\n#create empty list to store our calculations\nCtyMpgByCyl = []\n\n#iterate over all cylinder levels and then over all dics\nfor c in cylinders:\n    summpg = 0\n    cyltypecount = 0\n    #iterate over dics\n    for d in mpg:\n        #if the cylinder type matches add the cty mpg and increment the count\n        if d['cyl'] == c:\n            summpg += float(d['cty'])\n            cyltypecount += 1\n    # append the tuple ('cylinder', 'avg mpg')\n    CtyMpgByCyl.append((c, summpg/cyltypecount))\n\n#sort the list (lambda will be covered a bit later)\nCtyMpgByCyl.sort(key=lambda x: x[0])\nCtyMpgByCyl\n\n[('4', 21.012345679012345),\n ('5', 20.5),\n ('6', 16.21518987341772),\n ('8', 12.571428571428571)]\n\n\nNext, lets find the average highway MPG for the different vehicle classes.\n\n#find the different vehicle classes\nvehicleclass = set(d['class'] for d in mpg)\nvehicleclass\n\n{'2seater', 'compact', 'midsize', 'minivan', 'pickup', 'subcompact', 'suv'}\n\n\n\nHwyMpgByClass = []\n\nfor t in vehicleclass:\n    summpg = 0\n    vclasscount = 0\n    for d in mpg:\n        if d['class'] == t:\n            summpg += float(d['hwy'])\n            vclasscount += 1\n    HwyMpgByClass.append((t, summpg/vclasscount))\n\nHwyMpgByClass.sort(key=lambda x : x[1])\nHwyMpgByClass\n\n[('pickup', 16.87878787878788),\n ('suv', 18.129032258064516),\n ('minivan', 22.363636363636363),\n ('2seater', 24.8),\n ('midsize', 27.29268292682927),\n ('subcompact', 28.142857142857142),\n ('compact', 28.29787234042553)]"
  },
  {
    "objectID": "code/1_intro.html#dates-and-times",
    "href": "code/1_intro.html#dates-and-times",
    "title": "2  Introduction into python",
    "section": "2.6 Dates and Times",
    "text": "2.6 Dates and Times\nOne of the most common legacy methods for storing the date and time in online transactions systems is based on the offset from the epoch, which is January 1, 1970.\nIn Python, you can get the current time since the epoch using the time module. You can then create a time stamp using the from time stamp function on the date time object. When we print this value out, we see that the year, month, day, and so forth are also printed out.\n\nimport datetime as dt\nimport time as tm\n\ntime returns the current time in seconds since the Epoch. (January 1st, 1970)\n\ntm.time()\n\n1671458686.8570611\n\n\nCreate a timestamp:\n\ndtnow = dt.datetime.fromtimestamp(tm.time())\ndtnow\n\ndatetime.datetime(2022, 12, 19, 15, 4, 46, 864421)\n\n\nThe date time object has handy attributes to get the representative hour, day, seconds, etc.\n\n# get year, month, day, etc.from a datetime\ndtnow.year, dtnow.month, dtnow.day, dtnow.hour, dtnow.minute, dtnow.second  \n\n(2022, 12, 19, 15, 4, 46)\n\n\nDate time objects allow for simple math using time deltas. For instance, here, we can create a time delta of 100 days, then do subtraction and comparisons with the date time object.\n\n#create a timedelta of 100 days\ndelta = dt.timedelta(days = 100)\ndelta\n\ndatetime.timedelta(days=100)\n\n\n\n#return the current local date\ntoday = dt.date.today()\ntoday\n\ndatetime.date(2022, 12, 19)\n\n\n\n#extract the data 100 days ago\ntoday - delta\n\ndatetime.date(2022, 9, 10)\n\n\n\n#compare dates\ntoday > today - delta\n\nTrue"
  },
  {
    "objectID": "code/1_intro.html#objects-and-map",
    "href": "code/1_intro.html#objects-and-map",
    "title": "2  Introduction into python",
    "section": "2.7 Objects and map()",
    "text": "2.7 Objects and map()\nWe can define a class using the class keyword.\nClasses in Python are generally named using camel case, which means the first character of each word is capitalized.\nClass variables can also be declared. These are just variables which are shared across all instances. So in this example, we’re saying that the default for all people is at the school of information.\nTo define a method, you just write it as you would have a function. The one change, is that to have access to the instance, which a method is being invoked upon, you must include self, in the method signature. Similarly, if you want to refer to instance variables set on the object, you prepend them with the word self, with a full stop.\nIn this definition of a person, for instance, we have written two methods. Set name and set location. And both change instance bound variables, called name and location respectively\n\nclass Person:\n    #set a class variable\n    department = 'School of Information'\n    \n    #define a method\n    def set_name(self, new_name):\n        self.name = new_name\n    \n    def set_location(self, new_location):\n        self.location = new_location\n    \nperson = Person()\nperson.set_name('Chris Vrooks')\nperson.set_location('Mi, USA')\n\nprint('{} lives in {} and works in the department {}'. format(person.name,\nperson.location, person.department))\n\nChris Vrooks lives in Mi, USA and works in the department School of Information\n\n\nThere are a couple of implications of object-oriented programming in Python:\n\nObjects in Python do not have private or protected members. If you instantiate an object, you have full access to any of the methods or attributes of that object\nThere’s no need for an explicit constructor when creating objects in Python. You can add a constructor if you want to by declaring the __init__ method\n\nThe map function is one of the basis for functional programming in Python, it executes a specified function for each item in an iterable.\nFunctional programming is a programming paradigm in which you explicitly declare all parameters which could change through execution of a given function. Thus functional programming is referred to as being side-effect free, because there is a software contract that describes what can actually change by calling a function.\nThe map built-in function is one example of a functional programming feature of Python, that ties together a number of aspects of the language.\nThe map function signature looks like this: - The first parameters of function that you want executed - The second parameter, and every following parameter, is something which can be iterated upon\nImagine we have two list of numbers, maybe prices from two different stores on exactly the same items. And we wanted to find the minimum that we would have to pay if we bought the cheaper item between the two stores. To do this, we could iterate through each list, comparing items and choosing the cheapest. With map, we can do this comparison in a single statement.\n\nstore1 = [10.00, 11.00, 12.34, 2.34]\nstore2 = [9.00, 11.10, 12.34, 2.01]\n\ncheapest = map(min, store1, store2)\ncheapest\n\n<map at 0x7fae68fef490>\n\n\nWhen we go to print out the map, we see that we get an odd reference value instead of a list of items that we’re expecting. This is called lazy evaluation. In Python, the map function returns to you a map object. It doesn’t actually try and run the function min on two items, until you look inside for a value. This allows us to have very efficient memory management, even though something might be computationally complex.\nMaps are iterable, just like lists and tuples, so we can use a for loop to look at all of the values in the map.\n\nfor item in cheapest:\n    print(item)\n\nprint('')\n\n9.0\n11.0\n12.34\n2.01\n\n\n\nQuestion:\nHere is a list of faculty teaching this MOOC. Can you write a function and apply it using map() to get a list of all faculty titles and last names (e.g. [‘Dr. Brooks’, ‘Dr. Collins-Thompson’, …]) ?\n\npeople = ['Dr. Christopher Brooks', 'Dr. Kevyn Collins-Thompson', 'Dr. VG Vinod Vydiswaran', 'Dr. Daniel Romero']\n\ndef split_title_and_name(person):\n    title = person.split()[0]\n    lastname = person.split()[-1]\n    return '{} {}'.format(title, lastname)\n\nlist(map(split_title_and_name, people))\n\n['Dr. Brooks', 'Dr. Collins-Thompson', 'Dr. Vydiswaran', 'Dr. Romero']"
  },
  {
    "objectID": "code/1_intro.html#advanced-python-lambda-and-list-comprehensions",
    "href": "code/1_intro.html#advanced-python-lambda-and-list-comprehensions",
    "title": "2  Introduction into python",
    "section": "2.8 Advanced Python Lambda and List Comprehensions",
    "text": "2.8 Advanced Python Lambda and List Comprehensions\nLambda’s are Python’s way of creating anonymous functions. These are the same as other functions, but they have no name. The intent is that they’re simple or short lived and it’s easier just to write out the function in one line instead of going to the trouble of creating a named function.\nYou declare a lambda function with the word lambda followed by a list of arguments, followed by a colon and then a single expression. This is key: There’s only one expression to be evaluated in a lambda. The expression value is returned on execution of the lambda.\n\nmy_function = lambda a,b,c: a + b\n\nThe return of a lambda is a function reference. So in the case above, we would execute my_function and pass in three different parameters.\n\nmy_function(4,5,6)\n\n9\n\n\nNote that you can’t have default values for lambda parameters and you can’t have complex logic inside of the lambda itself because you’re limited to a single expression. Therefore, lambdas are more limited than full function definitions.\nAnother example, in which we add 10 to argument a, and return the result:\n\nx = lambda a : a + 10\nprint(x(5))\n\n15\n\n\nYou can apply the function above to an argument by surrounding the function and its argument with parentheses:\n\n(lambda x: x + 1)(5)\n\n6\n\n\nBecause a lambda function is an expression, it can be named. Therefore you could write the previous code as follows:\n\nadd_one = lambda x: x + 1\nadd_one(5)\n\n6\n\n\nExercise\nConvert the code below into a lambda:\n\npeople = ['Dr. Christopher Brooks', 'Dr. Kevyn Collins-Thompson', 'Dr. VG Vinod Vydiswaran', 'Dr. Daniel Romero']\n\ndef split_title_and_name(person):\n    return person.split()[0] + ' ' + person.split()[-1]\n\nlist(map(split_title_and_name, people))\n\n['Dr. Brooks', 'Dr. Collins-Thompson', 'Dr. Vydiswaran', 'Dr. Romero']\n\n\n\n#option 1\nfor person in people:\n    print((lambda x: x.split()[0] + ' ' + x.split()[-1])(person))\n\nprint('')\n\nDr. Brooks\nDr. Collins-Thompson\nDr. Vydiswaran\nDr. Romero\n\n\n\n\n#option 2\nlist(map(lambda person: person.split()[0] + ' ' + person.split()[-1], people))\n\n['Dr. Brooks', 'Dr. Collins-Thompson', 'Dr. Vydiswaran', 'Dr. Romero']\n\n\n\n2.8.1 List comprehensions\nWe’ve learned a lot about sequences and in Python. Tuples, lists, dictionaries and so forth.\nSequences are structures that we can iterate over, and often we create these through loops or by reading in data from a file.\nPython has built in support for creating these collections using a more abbreviated syntax called list comprehensions. The basic syntax looks as follows:\nnewlist = [expression for item in iterable if condition == True]\nLet’s start with how we usually write for loops:\n\nmy_list = []\n\nfor number in range(0,100):\n    #check for evenly dividing numbers\n    if number % 2 == 0:\n        my_list.append(number)\n\nmy_list\n\n[0,\n 2,\n 4,\n 6,\n 8,\n 10,\n 12,\n 14,\n 16,\n 18,\n 20,\n 22,\n 24,\n 26,\n 28,\n 30,\n 32,\n 34,\n 36,\n 38,\n 40,\n 42,\n 44,\n 46,\n 48,\n 50,\n 52,\n 54,\n 56,\n 58,\n 60,\n 62,\n 64,\n 66,\n 68,\n 70,\n 72,\n 74,\n 76,\n 78,\n 80,\n 82,\n 84,\n 86,\n 88,\n 90,\n 92,\n 94,\n 96,\n 98]\n\n\nWe can do the same with a list comprehension. We start the list comprehension with the value we want in the list. In this case, it’s a number. Then we put it in the for-loop, and then finally, we add any condition clauses.\n\nmy_list = [number for number in range(0,100) if number % 2 == 0]\nmy_list\n\n[0,\n 2,\n 4,\n 6,\n 8,\n 10,\n 12,\n 14,\n 16,\n 18,\n 20,\n 22,\n 24,\n 26,\n 28,\n 30,\n 32,\n 34,\n 36,\n 38,\n 40,\n 42,\n 44,\n 46,\n 48,\n 50,\n 52,\n 54,\n 56,\n 58,\n 60,\n 62,\n 64,\n 66,\n 68,\n 70,\n 72,\n 74,\n 76,\n 78,\n 80,\n 82,\n 84,\n 86,\n 88,\n 90,\n 92,\n 94,\n 96,\n 98]\n\n\nAnother example:\n\nfruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\n\nnewlist = [x for x in fruits if \"a\" in x]\n\nprint(newlist)\n\n['apple', 'banana', 'mango']\n\n\nNotice, that the if statement is optional:\n\nnewlist = [x for x in fruits]\nnewlist\n\n['apple', 'banana', 'cherry', 'kiwi', 'mango']\n\n\nThe expression is the current item in the iteration, but it is also the outcome, which you can manipulate before it ends up like a list item in the new list:\n\nnewlist = [x.upper() for x in fruits]\nnewlist\n\n['APPLE', 'BANANA', 'CHERRY', 'KIWI', 'MANGO']\n\n\nThe expression can also contain conditions, not like a filter, but as a way to manipulate the outcome:\n\nnewlist = [x if x != \"banana\" else \"orange\" for x in fruits]\nnewlist\n\n['apple', 'orange', 'cherry', 'kiwi', 'mango']\n\n\nExercise:\nThe function to convert:\n\ndef times_tables():\n    lst = []\n    for i in range(10):\n        for j in range (10):\n            lst.append(i*j)\n    return lst\n\nThe list comprehension:\n\ntimes_tables() == [i*j for i in range(10) for j in range(10)]\n\nTrue\n\n\nQuestion\nMany organizations have user ids which are constrained in some way. Imagine you work at an internet service provider and the user ids are all two letters followed by two numbers (e.g. aa49). Your task at such an organization might be to hold a record on the billing activity for each possible user.\nWrite an initialization line as a single list comprehension which creates a list of all possible user ids. Assume the letters are all lower case.\n\n#lowercase = 'abcdefghijklmnopqrstuvwxyz'\n#digits = '0123456789'\n\nmy_list = []\nlowercase = 'ab'\ndigits = '01'\n\nmy_list = [a+b+c+d for a in lowercase for b in lowercase for c in digits for d in digits]\n\nmy_list[0:4]\n\n['aa00', 'aa01', 'aa10', 'aa11']\n\n\n\nlen(my_list)\n\n16\n\n\nanswer = [???] correct_answer == answer ```"
  },
  {
    "objectID": "code/2_numpy.html",
    "href": "code/2_numpy.html",
    "title": "3  Numpy",
    "section": "",
    "text": "Numpy is the fundamental package for numeric computing with Python. It provides powerful ways to create, store, and/or manipulate data, which makes it able to seamlessly and speedily integrate with a wide variety of databases. This is also the foundation that Pandas is built on, which is a high-performance data-centric package that we will learn later in the course.\nIn this lecture, we will talk about creating array with certain data types, manipulating array, selecting elements from arrays, and loading dataset into array. Such functions are useful for manipulating data and understanding the functionalities of other common Python data packages."
  },
  {
    "objectID": "code/2_numpy.html#array-creation",
    "href": "code/2_numpy.html#array-creation",
    "title": "3  Numpy",
    "section": "3.1 Array creation",
    "text": "3.1 Array creation\n\n# Arrays are displayed as a list or list of lists and can be created through list as well. When creating an\n# array, we pass in a list as an argument in numpy array\na = np.array([1, 2, 3])\nprint(a)\n\n[1 2 3]\n\n\n\n# We can print the number of dimensions of a list using the ndim attribute\nprint(a.ndim)\n\n1\n\n\n\n# If we pass in a list of lists in numpy array, we create a multi-dimensional array, for instance, a matrix\nb = np.array([[1,2,3],[4,5,6]])\nb\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n\n# We can print out the length of each dimension by calling the shape attribute, which returns a tuple\nb.shape\n\n(2, 3)\n\n\n\n# We can also check the type of items in the array\na.dtype\n\ndtype('int64')\n\n\n\n# Besides integers, floats are also accepted in numpy arrays\nc = np.array([2.2, 5, 1.1])\nc.dtype.name\n\n'float64'\n\n\n\n# Let's look at the data in our array\nc\n\narray([2.2, 5. , 1.1])\n\n\nNote that numpy automatically converts integers, like 5, up to floats, since there is no loss of precision. Numpy will try and give you the best data type format possible to keep your data types homogeneous, which means all the same, in the array.\nSometimes we know the shape of an array that we want to create, but not what we want to be in it. numpy offers several functions to create arrays with initial placeholders, such as zero’s or one’s.\n\n# Lets create two arrays, both the same shape but with different filler values\nd = np.zeros((2,3))\nprint(d)\n\n[[0. 0. 0.]\n [0. 0. 0.]]\n\n\n\ne = np.ones((2,3))\nprint(e)\n\n[[1. 1. 1.]\n [1. 1. 1.]]\n\n\n\n# We can also generate an array with random numbers\nnp.random.rand(2,3)\n\narray([[0.81579341, 0.16382068, 0.05598863],\n       [0.30621707, 0.67968134, 0.98771857]])\n\n\nYou’ll see zeros, ones, and rand used quite often to create example arrays, especially in stack overflow posts and other forums.\nWe can also create a sequence of numbers in an array with the arrange() function:\n\nThe fist argument is the starting bound\nthe second argument is the ending bound\nthe third argument is the difference between each consecutive numbers\n\n\n# Let's create an array of every even number from ten (inclusive) to fifty (exclusive)\nf = np.arange(10, 50, 2)\nf\n\narray([10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,\n       44, 46, 48])\n\n\nIf we want to generate a sequence of floats, we can use the linspace() function. In this function the third argument isn’t the difference between two numbers, but the total number of items you want to generate\n\n#create 15 numbers from 0 (inclusive) to 2 (inclusive)\nnp.linspace( 0, 2, 15 ) \n\narray([0.        , 0.14285714, 0.28571429, 0.42857143, 0.57142857,\n       0.71428571, 0.85714286, 1.        , 1.14285714, 1.28571429,\n       1.42857143, 1.57142857, 1.71428571, 1.85714286, 2.        ])"
  },
  {
    "objectID": "code/2_numpy.html#array-operations",
    "href": "code/2_numpy.html#array-operations",
    "title": "3  Numpy",
    "section": "3.2 Array operations",
    "text": "3.2 Array operations\nWe can do many things on arrays, such as mathematical manipulation (addition, subtraction, square, exponents) as well as use boolean arrays, which are binary values. We can also do matrix manipulation such as product, transpose, inverse, and so forth.\nArithmetic operators on array apply elementwise.\n\n# Let's create a couple of arrays\na = np.array([10,20,30,40])\nb = np.array([1, 2, 3,4])\n\n# Now let's look at a minus b\nc = a-b\nprint(c)\n\n[ 9 18 27 36]\n\n\n\n# And let's look at a times b\nd = a*b\nprint(d)\n\n[ 10  40  90 160]\n\n\nWith arithmetic manipulation, we can convert current data to the way we want it to be. Here’s a real-world problem I face - I moved down to the United States about 6 years ago from Canada. In Canada we use celcius for temperatures, and my wife still hasn’t converted to the US system which uses farenheit. With numpy I could easily convert a number of farenheit values, say the weather forecase, to ceclius:\n\n# Let's create an array of typical Ann Arbor winter farenheit values\nfarenheit = np.array([0,-10,-5,-15,0])\n\ncelcius = (farenheit - 31) * (5/9)\ncelcius\n\narray([-17.22222222, -22.77777778, -20.        , -25.55555556,\n       -17.22222222])\n\n\nAnother useful and important manipulation is the boolean array. We can apply an operator on an array, and a boolean array will be returned for any element in the original, with True being emitted if it meets the condition and False otherwise. For instance, if we want to get a boolean array to check celcius degrees that are greater than -20 degrees\n\ncelcius > -20\n\narray([ True, False, False, False,  True])\n\n\nHere’s another example, we could use the modulus operator to check numbers in an array to see if they are even. Recall that modulus does division but throws away everything but the remainder (decimal) portion)\n\ncelcius%2 == 0\n\narray([False, False,  True, False, False])\n\n\nBesides element-wise manipulation, it is important to know that numpy supports matrix manipulation. Let’s look at matrix product. if we want to do elementwise product, we use the “*” sign\n\nA = np.array([[1,1],[0,1]])\nB = np.array([[2,0],[3,4]])\nprint(A*B)\n\n[[2 0]\n [0 4]]\n\n\nIf we want to do matrix product, we use the “@” sign or use the dot function\n\nprint(A@B)\n\n[[5 4]\n [3 4]]\n\n\nA few more linear algebra concepts are worth layering in here. You might recall that the product of two matrices is only plausible when the inner dimensions of the two matrices are the same. The dimensions refer to the number of elements both horizontally and vertically in the rendered matrices you’ve seen here. We can use numpy to quickly see the shape of a matrix:\n\nA.shape\n\n(2, 2)\n\n\nWhen manipulating arrays of different types, the type of the resulting array will correspond to the more general of the two types. This is called upcasting.\n\n# Let's create an array of integers\narray1 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(array1.dtype)\n\n# Now let's create an array of floats\narray2 = np.array([[7.1, 8.2, 9.1], [10.4, 11.2, 12.3]])\nprint(array2.dtype)\n\nint64\nfloat64\n\n\nIntegers (int) are whole numbers only, and Floating point numbers (float) can have a whole number portion and a decimal portion. The 64 in this example refers to the number of bits that the operating system is reserving to represent the number, which determines the size (or precision) of the numbers that can be represented.\n\n# Let's do an addition for the two arrays\narray3=array1+array2\nprint(array3)\nprint(array3.dtype)\n\n[[ 8.1 10.2 12.1]\n [14.4 16.2 18.3]]\nfloat64\n\n\nNotice how the items in the resulting array have been upcast into floating point numbers.\nNumpy arrays have many interesting aggregation functions on them, such as sum(), max(), min(), and mean().\n\nprint(array3.sum())\nprint(array3.max())\nprint(array3.min())\nprint(array3.mean())\n\n79.3\n18.3\n8.1\n13.216666666666667\n\n\nFor two dimensional arrays, we can do the same thing for each row or column, let’s create an array with 15 elements, ranging from 1 to 15, with a dimension of 3X5.\n\nb = np.arange(1,16,1).reshape(3,5)\nprint(b)\n\n[[ 1  2  3  4  5]\n [ 6  7  8  9 10]\n [11 12 13 14 15]]\n\n\nNow, we often think about two dimensional arrays being made up of rows and columns, but you can also think of these arrays as just a giant ordered list of numbers, and the shape of the array, the number of rows and columns, is just an abstraction that we have for a particular purpose. Actually, this is exactly how basic images are stored in computer environments.\nLet’s take a look at an example and see how numpy comes into play.\n\n# For this demonstration I'll use the python imaging library (PIL) and a function to display images in the\n# Jupyter notebook\nfrom PIL import Image\nfrom IPython.display import display\n\n# And let's just look at the image I'm talking about\nim = Image.open('../images/chris.tiff')\ndisplay(im)\n\n\n\n\n\n# Now, we can convert this PIL image to a numpy array\narray=np.array(im)\nprint(array.shape)\nprint(array[:1])\n\n(200, 200)\n[[118 117 118 118 112 103  92  82  66  56  45  39  38  40  43  46  53  53\n   53  52  48  43  39  36  19  15  15  16  24  28  33  35  39  34  28  23\n   15   8   8  16  41  60  91 118 135 141 141 141 133 120 103  87  73  68\n   77  91 105 109 117 121 120 114 104  98  84  76  70  72  76  82  94 107\n  113 121 126 132 133 135 137 139 144 145 150 157 166 171 170 168 169 157\n  145 138 130 124 125 134 137 141 145 148 148 143 138 136 134 133 133 133\n  138 142 147 150 146 140 126 108  85  61  44  34  39  49  65  83 104 125\n  143 155 150 155 153 146 135 120  99  80  69  63  65  78  98 116 134 147\n  155 165 170 166 159 154 146 137 125 119 117 122 127 129 131 135 138 142\n  146 150 152 150 148 145 144 141 139 138 139 137 133 129 124 126 128 129\n  129 127 125 123 120 120 124 126 125 122 117 114 115 114 113 108 105 103\n  107 110]]\n\n\n\narray.dtype\n\ndtype('uint8')\n\n\nHere we see that we have a 200x200 array and that the values are all uint8. The uint means that they are unsigned integers (so no negative numbers) and the 8 means 8 bits per byte. This means that each value can be up to 2222222*2=256 in size (well, actually 255, because we start at zero).\nFor black and white images black is stored as 0 and white is stored as 255. So if we just wanted to invert this image we could use the numpy array to do so\n\n# Let's create an array the same shape\nmask=np.full(array.shape,255)\nmask\n\narray([[255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255],\n       ...,\n       [255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255]])\n\n\n\n# Now let's subtract that from the modified array\nmodified_array=array-mask\n\n# And lets convert all of the negative values to positive values\nmodified_array=modified_array*-1\n\n# And as a last step, let's tell numpy to set the value of the datatype correctly\nmodified_array=modified_array.astype(np.uint8)\nmodified_array\n\narray([[137, 138, 137, ..., 152, 148, 145],\n       [142, 142, 142, ..., 155, 152, 149],\n       [147, 147, 148, ..., 160, 157, 153],\n       ...,\n       [ 78,  74,  73, ...,  62,  57,  63],\n       [ 77,  73,  72, ...,  62,  54,  66],\n       [ 77,  73,  71, ...,  62,  54,  68]], dtype=uint8)\n\n\nAnd lastly, lets display this new array. We do this by using the fromarray() function in the python imaging library to convert the numpy array into an object jupyter can render\n\ndisplay(Image.fromarray(modified_array))\n\n\n\n\nOk, remember how I started this by talking about how we could just think of this as a giant array of bytes, and that the shape was an abstraction? Well, we could just decide to reshape the array and still try and render it. PIL is interpreting the individual rows as lines, so we can change the number of lines and columns if we want to. What do you think that would look like?\n\nreshaped=np.reshape(modified_array,(100,400))\nprint(reshaped.shape)\ndisplay(Image.fromarray(reshaped))\n\n(100, 400)\n\n\n\n\n\nBy reshaping the array to be only 100 rows high but 400 columns we’ve essentially doubled the image by taking every other line and stacking them out in width. This makes the image look more stretched out too.\nThis isn’t an image manipulation course, but the point was to show you that these numpy arrays are really just abstractions on top of data, and that data has an underlying format (in this case, uint8). But further, we can build abstractions on top of that, such as computer code which renders a byte as either black or white, which has meaning to people."
  },
  {
    "objectID": "code/2_numpy.html#indexing-slicing-iterating",
    "href": "code/2_numpy.html#indexing-slicing-iterating",
    "title": "3  Numpy",
    "section": "3.3 Indexing, Slicing, Iterating",
    "text": "3.3 Indexing, Slicing, Iterating\nIndexing, slicing and iterating are extremely important for data manipulation and analysis because these techniques allow us to select data based on conditions, and copy or update data.\n\n3.3.1 Indexing\nFirst we are going to look at integer indexing. A one-dimensional array, works in similar ways as a list. To get an element in a one-dimensional array, we simply use the offset index.\n\na = np.array([1,3,5,7])\na[2]\n\n5\n\n\nFor multidimensional array, we need to use integer array indexing, let’s create a new multidimensional array:\n\na = np.array([[1,2], [3, 4], [5, 6]])\na\n\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n\nIf we want to select one certain element, we can do so by entering the index, which is comprised of two integers the first being the row, and the second the column.\n\na[1,1]\n\n4\n\n\nIf we want to get multiple elements for example, 1, 4, and 6 and put them into a one-dimensional array we can enter the indices directly into an array function:\n\nnp.array([a[0, 0], a[1, 1], a[2, 1]])\n\narray([1, 4, 6])\n\n\nWe can also do that by using another form of array indexing, which essentially “zips” the first list and the second list up:\n\nprint(a[[0, 1, 2], [0, 1, 1]])\n\n[1 4 6]\n\n\n\n\n3.3.2 Boolean indexing\nBoolean indexing allows us to select arbitrary elements based on conditions. For example, in the matrix we just talked about we want to find elements that are greater than 5 so we set up a conditon a >5 :\n\nprint(a >5)\n\n[[False False]\n [False False]\n [False  True]]\n\n\n\n\n\nThis returns a boolean array showing that if the value at the corresponding index is greater than 5.\n\n\n3.3.3 Slicing\nSlicing is a way to create a sub-array based on the original array. For one-dimensional arrays, slicing works in similar ways to a list. To slice, we use the : sign. For instance, if we put :3 in the indexing brackets, we get elements from index 0 to index 3 (excluding index 3)\n\na = np.array([0,1,2,3,4,5])\nprint(a[:3])\n\n[0 1 2]\n\n\nBy putting 2:4 in the bracket, we get elements from index 2 to index 4 (excluding index 4)\n\nprint(a[2:4])\n\n[2 3]\n\n\nFor multi-dimensional arrays, it works similarly, lets see an example\n\na = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\na\n\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n\n\nFirst, if we put one argument in the array, for example a[:2] then we would get all the elements from the first (0th) and second row (1th)\n\na[:2]\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\nIf we add another argument to the array, for example a[:2, 1:3], we get the first two rows but then the second and third column values only\n\na[:2, 1:3]\n\narray([[2, 3],\n       [6, 7]])\n\n\nSo, in multidimensional arrays, the first argument is for selecting rows, and the second argument is for selecting columns\nIt is important to realize that a slice of an array is a view into the same data. This is called passing by reference. So modifying the sub array will consequently modify the original array\nHere I’ll change the element at position [0, 0], which is 2, to 50, then we can see that the value in the original array is changed to 50 as well\n\na = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\nsub_array = a[:2, 1:3]\nsub_array\n\narray([[2, 3],\n       [6, 7]])\n\n\n\nprint(\"sub array index [0,0] value before change:\", sub_array[0,0])\n\nsub array index [0,0] value before change: 2\n\n\n\nsub_array[0,0] = 50\nsub_array\n\narray([[50,  3],\n       [ 6,  7]])\n\n\n\nprint(\"sub array index [0,0] value after change:\", sub_array[0,0])\nprint(\"original array index [0,1] value after change:\", a[0,1])\n\nsub array index [0,0] value after change: 50\noriginal array index [0,1] value after change: 50"
  },
  {
    "objectID": "code/2_numpy.html#trying-numpy-with-datasets",
    "href": "code/2_numpy.html#trying-numpy-with-datasets",
    "title": "3  Numpy",
    "section": "3.4 Trying numpy with datasets",
    "text": "3.4 Trying numpy with datasets"
  }
]