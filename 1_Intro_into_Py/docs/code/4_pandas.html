<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Applied Data Science Course 1 - 5&nbsp; Pandas</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../code/5_pandas2.html" rel="next">
<link href="../code/3_regular_expressions.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body class="nav-sidebar floating">


<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Pandas</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Applied Data Science Course 1</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Data Science in Python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/1_intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction into python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/2_numpy.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Numpy</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/3_regular_expressions.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Regex</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/4_pandas.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Pandas</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/5_pandas2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data processing with pandas</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/6_idioms.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Panda idioms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/7_groupby.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Grouping data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/8_scales.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Scales</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/9_pivot.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Pivot tables</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../code/10_date_and_time.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Dates and times</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#series-data-structure" id="toc-series-data-structure" class="nav-link active" data-scroll-target="#series-data-structure"><span class="toc-section-number">5.1</span>  Series data structure</a></li>
  <li><a href="#missing-data" id="toc-missing-data" class="nav-link" data-scroll-target="#missing-data"><span class="toc-section-number">5.2</span>  Missing data</a></li>
  <li><a href="#creating-series-from-dictionaries" id="toc-creating-series-from-dictionaries" class="nav-link" data-scroll-target="#creating-series-from-dictionaries"><span class="toc-section-number">5.3</span>  Creating Series from dictionaries</a></li>
  <li><a href="#querying-a-series" id="toc-querying-a-series" class="nav-link" data-scroll-target="#querying-a-series"><span class="toc-section-number">5.4</span>  Querying a Series</a></li>
  <li><a href="#appending-series" id="toc-appending-series" class="nav-link" data-scroll-target="#appending-series"><span class="toc-section-number">5.5</span>  Appending Series</a></li>
  <li><a href="#dataframes" id="toc-dataframes" class="nav-link" data-scroll-target="#dataframes"><span class="toc-section-number">5.6</span>  Dataframes</a></li>
  <li><a href="#dropping-data" id="toc-dropping-data" class="nav-link" data-scroll-target="#dropping-data"><span class="toc-section-number">5.7</span>  Dropping data</a></li>
  <li><a href="#adding-columns-to-a-df" id="toc-adding-columns-to-a-df" class="nav-link" data-scroll-target="#adding-columns-to-a-df"><span class="toc-section-number">5.8</span>  Adding columns to a df</a></li>
  <li><a href="#dataframe-indexing-and-loading" id="toc-dataframe-indexing-and-loading" class="nav-link" data-scroll-target="#dataframe-indexing-and-loading"><span class="toc-section-number">5.9</span>  DataFrame Indexing and Loading</a></li>
  <li><a href="#renaming-columns-in-a-df" id="toc-renaming-columns-in-a-df" class="nav-link" data-scroll-target="#renaming-columns-in-a-df"><span class="toc-section-number">5.10</span>  Renaming columns in a df</a></li>
  <li><a href="#querying-a-dataframe" id="toc-querying-a-dataframe" class="nav-link" data-scroll-target="#querying-a-dataframe"><span class="toc-section-number">5.11</span>  Querying a dataframe</a>
  <ul class="collapse">
  <li><a href="#boolean-masking" id="toc-boolean-masking" class="nav-link" data-scroll-target="#boolean-masking"><span class="toc-section-number">5.11.1</span>  Boolean masking</a></li>
  </ul></li>
  <li><a href="#indexing-dataframes" id="toc-indexing-dataframes" class="nav-link" data-scroll-target="#indexing-dataframes"><span class="toc-section-number">5.12</span>  Indexing dataframes</a></li>
  <li><a href="#missing-values" id="toc-missing-values" class="nav-link" data-scroll-target="#missing-values"><span class="toc-section-number">5.13</span>  Missing values</a></li>
  <li><a href="#example-manipulating-a-dataframe" id="toc-example-manipulating-a-dataframe" class="nav-link" data-scroll-target="#example-manipulating-a-dataframe"><span class="toc-section-number">5.14</span>  Example: Manipulating a dataframe</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Pandas</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="series-data-structure" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="series-data-structure"><span class="header-section-number">5.1</span> Series data structure</h2>
<p>The series is one of the core data structures in pandas. You think of it a cross between a list and a dictionary. The items are all stored in an order and there’s labels with which you can retrieve them. An easy way to visualize this is two columns of data. The first is the special index, a lot like keys in a dictionary. While the second is your actual data. It’s important to note that the data column has a label of its own and can be retrieved using the <code>.name</code> attribute. This is different than with dictionaries and is useful when it comes to merging multiple columns of data.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> timeit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You can create a series by passing in a list of values. When you do this, Pandas automatically assigns an index starting with zero and sets the name of the series to None. One of the easiest ways to create a series is to use an array-like object, like a list.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>students <span class="op">=</span> [<span class="st">'Alice'</span>, <span class="st">'Jack'</span>, <span class="st">'Molly'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we just call the Series function in pandas and pass in the students:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pd.Series(students)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>0    Alice
1     Jack
2    Molly
dtype: object</code></pre>
</div>
</div>
<p>The result is a Series object which is nicely rendered to the screen.</p>
<p>We see here that the pandas has automatically identified the type of data in this Series as “object” and set the dytpe parameter as appropriate. We see that the values are indexed with integers, starting at zero.</p>
<p>We don’t have to use strings. If we passed in a list of whole numbers, for instance, we could see that panda sets the type to int64. Underneath panda stores series values in a typed array using the Numpy library. This offers significant speedup when processing data versus traditional python lists.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>pd.Series(numbers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>0    1
1    2
2    3
dtype: int64</code></pre>
</div>
</div>
<p>And we see on my architecture that the result is a dtype of int64 objects</p>
</section>
<section id="missing-data" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="missing-data"><span class="header-section-number">5.2</span> Missing data</h2>
<p>There’s some other typing details that exist for performance that are important to know. The most important is how Numpy and thus pandas handle <strong>missing data</strong>.</p>
<p>In Python, we have the none type to indicate a lack of data. But what do we do if we want to have a typed list like we do in the series object?</p>
<p>Underneath, pandas does some type conversion. If we create a list of strings and we have one element, a None type, pandas inserts it as a None and uses the type object for the underlying array.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>students <span class="op">=</span> [<span class="st">'Alice'</span>, <span class="st">'Jack'</span>, <span class="va">None</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>pd.Series(students)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>0    Alice
1     Jack
2     None
dtype: object</code></pre>
</div>
</div>
<p>However, if we create a list of numbers, integers or floats, and put in the None type, pandas automatically converts this to a special floating point value designated as NaN, which stands for “Not a Number”.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="va">None</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>pd.Series(numbers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>0    1.0
1    2.0
2    NaN
dtype: float64</code></pre>
</div>
</div>
<p>You’ll notice a couple of things:</p>
<ul>
<li>First, NaN is a different value.</li>
<li>Second, pandas set the dytpe of this series to floating point numbers instead of object or ints. That’s maybe a bit of a surprise - why not just leave this as an integer?</li>
</ul>
<p>Underneath, pandas represents NaN as a floating point number, and because integers can be typecast to floats, pandas went and converted our integers to floats. So when you’re wondering why the list of integers you put into a Series is not floats, it’s probably because there is some missing data.</p>
<p>It is important to stress that None and NaN might be being used by the data scientist in the same way, to denote missing data, but that underneath these are not represented by pandas in the same way.</p>
<p><strong>NaN is <em>NOT</em> equivilent to None and when we try the equality test, the result is False.</strong></p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>np.nan <span class="op">==</span> <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>False</code></pre>
</div>
</div>
<p>It turns out that you actually can’t do an equality test of NAN to itself. When you do, the answer is always False.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>np.nan <span class="op">==</span> np.nan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>False</code></pre>
</div>
</div>
<p>Instead, you need to use special functions to test for the presence of not a number, such as the Numpy library <code>isnan()</code>.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>np.isnan(np.nan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>True</code></pre>
</div>
</div>
<p>So keep in mind when you see NaN, it’s meaning is similar to None, but it’s a numeric value and treated differently for efficiency reasons.</p>
</section>
<section id="creating-series-from-dictionaries" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="creating-series-from-dictionaries"><span class="header-section-number">5.3</span> Creating Series from dictionaries</h2>
<p>A series can be created directly from dictionary data. If you do this, the index is automatically assigned to the keys of the dictionary that you provided and not just incrementing integers.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>students_scores <span class="op">=</span> {<span class="st">'Alice'</span>: <span class="st">'Physics'</span>,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Jack'</span>: <span class="st">'Chemistry'</span>,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Molly'</span>: <span class="st">'English'</span>}</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(students_scores)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>Alice      Physics
Jack     Chemistry
Molly      English
dtype: object</code></pre>
</div>
</div>
<p>We see that, since it was string data, pandas set the data type of the series to “object”. We see that the index, the first column, is also a list of strings.</p>
<p>Once the series has been created, we can get the index object using the index attribute.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>s.index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>Index(['Alice', 'Jack', 'Molly'], dtype='object')</code></pre>
</div>
</div>
<p>As you play more with pandas you’ll notice that a lot of things are implemented as numpy arrays, and have the dtype value set. This is true of indicies, and here pandas inferred that we were using objects for the index.</p>
<p>Now, this is kind of interesting. The dtype of object is not just for strings, but for arbitrary objects. Lets create a more complex type of data, say, a list of tuples.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>students <span class="op">=</span> [(<span class="st">"Alice"</span>,<span class="st">"Brown"</span>), (<span class="st">"Jack"</span>, <span class="st">"White"</span>), (<span class="st">"Molly"</span>, <span class="st">"Green"</span>)]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>pd.Series(students)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>0    (Alice, Brown)
1     (Jack, White)
2    (Molly, Green)
dtype: object</code></pre>
</div>
</div>
<p>We see that each of the tuples is stored in the series object, and the type is object.</p>
<p>You can also separate your index creation from the data by passing in the index as a list explicitly to the series.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series([<span class="st">'Physics'</span>, <span class="st">'Chemistry'</span>, <span class="st">'English'</span>], index<span class="op">=</span>[<span class="st">'Alice'</span>, <span class="st">'Jack'</span>, <span class="st">'Molly'</span>])</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>Alice      Physics
Jack     Chemistry
Molly      English
dtype: object</code></pre>
</div>
</div>
<p>So what happens if your list of values in the index object are not aligned with the keys in your dictionary for creating the series? Well, pandas overrides the automatic creation to favor only and all of the indices values that you provided. So it will ignore from your dictionary all keys which are not in your index, and pandas will add None or NaN type values for any index value you provide, which is not in your dictionary key list.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>students_scores <span class="op">=</span> {<span class="st">'Alice'</span>: <span class="st">'Physics'</span>,</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Jack'</span>: <span class="st">'Chemistry'</span>,</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Molly'</span>: <span class="st">'English'</span>}</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co"># When I create the series object though I'll only ask for an index with three students, and I'll exclude Jack</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(students_scores, index<span class="op">=</span>[<span class="st">'Alice'</span>, <span class="st">'Molly'</span>, <span class="st">'Sam'</span>])</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>Alice    Physics
Molly    English
Sam          NaN
dtype: object</code></pre>
</div>
</div>
</section>
<section id="querying-a-series" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="querying-a-series"><span class="header-section-number">5.4</span> Querying a Series</h2>
<p>A pandas Series can be queried either by the index position or the index label. If you don’t give an index to the series when querying, the position and the label are effectively the same values.</p>
<ul>
<li>To query by numeric location, starting at zero, use the <code>iloc</code> attribute.</li>
<li>To query by the index label, you can use the <code>loc</code> attribute.</li>
</ul>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>students_classes <span class="op">=</span> {<span class="st">'Alice'</span>: <span class="st">'Physics'</span>,</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Jack'</span>: <span class="st">'Chemistry'</span>,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Molly'</span>: <span class="st">'English'</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Sam'</span>: <span class="st">'History'</span>}</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(students_classes)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>Alice      Physics
Jack     Chemistry
Molly      English
Sam        History
dtype: object</code></pre>
</div>
</div>
<p>So, for this series, if you wanted to see the fourth entry we would we would use the iloc attribute with the parameter 3.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>s.iloc[<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>'History'</code></pre>
</div>
</div>
<p>If you wanted to see what class Molly has, we would use the loc attribute with a parameter of Molly.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>s.loc[<span class="st">'Molly'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>'English'</code></pre>
</div>
</div>
<p>Keep in mind that <strong>iloc and loc are not methods, they are attributes</strong>. So you don’t use parentheses to query them, but square brackets instead, which is called the <strong>indexing operator</strong>.</p>
<p>Pandas tries to make our code a bit more readable and provides a sort of smart syntax using the indexing operator directly on the series itself. For instance, if you pass in an integer parameter, the operator will behave as if you want it to query via the iloc attribute</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>s[<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>'History'</code></pre>
</div>
</div>
<p>If you pass in an object, it will query as if you wanted to use the label based loc attribute.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>s[<span class="st">'Molly'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>'English'</code></pre>
</div>
</div>
<p>So what happens if your index is a list of integers? This is a bit complicated and Pandas can’t determine automatically whether you’re intending to query by index position or index label. So you need to be careful when using the indexing operator on the Series itself. The safer option is to be more explicit and use the iloc or loc attributes directly.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>class_code <span class="op">=</span> {<span class="dv">99</span>: <span class="st">'Physics'</span>,</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>              <span class="dv">100</span>: <span class="st">'Chemistry'</span>,</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>              <span class="dv">101</span>: <span class="st">'English'</span>,</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>              <span class="dv">102</span>: <span class="st">'History'</span>}</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(class_code)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>99       Physics
100    Chemistry
101      English
102      History
dtype: object</code></pre>
</div>
</div>
<p>If we try and call <code>s[0]</code> we get a key error because there’s no item in the classes list with an index of zero, instead we have to call iloc explicitly if we want the first item.</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">#s[0]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The code above will give us a <code>KeyError: 0</code></p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>s.iloc[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>'Physics'</code></pre>
</div>
</div>
<p>Now we know how to get data out of the series, let’s talk about working with the data. A common task is to want to consider all of the values inside of a series and do some sort of operation. This could be trying to find a certain number, or summarizing data or transforming the data in some way.</p>
<p>A typical programmatic approach to this would be to iterate over all the items in the series, and invoke the operation one is interested in. For instance, we could create a Series of integers representing student grades, and just try and get an average grade</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>grades <span class="op">=</span> pd.Series([<span class="dv">90</span>, <span class="dv">80</span>, <span class="dv">70</span>, <span class="dv">60</span>])</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>grades</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>0    90
1    80
2    70
3    60
dtype: int64</code></pre>
</div>
</div>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> grade <span class="kw">in</span> grades:</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    total <span class="op">+=</span> grade</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total<span class="op">/</span><span class="bu">len</span>(grades))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>75.0</code></pre>
</div>
</div>
<p>This works, but it’s slow. Modern computers can do many tasks simultaneously, especially, but not only, tasks involving mathematics.</p>
<p>Pandas and the underlying numpy libraries support a method of computation called <strong>vectorization.</strong> Vectorization works with most of the functions in the numpy library, including the sum function.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> np.<span class="bu">sum</span>(grades)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total<span class="op">/</span><span class="bu">len</span>(grades))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>75.0</code></pre>
</div>
</div>
<p>Now both of these methods create the same value, but is one actually faster? The Jupyter Notebook has a magic function which can help.</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> pd.Series(np.random.randint(<span class="dv">0</span>,<span class="dv">1000</span>,<span class="dv">10000</span>))</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co">#look at the first 5 items</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>numbers.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>0    368
1    720
2    203
3    686
4    962
dtype: int64</code></pre>
</div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">#control length of series</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(numbers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>10000</code></pre>
</div>
</div>
<p>Ok, we’re confident now that we have a big series. The ipython interpreter has something called <strong>magic functions</strong> begin with a percentage sign. If we type this sign and then hit the Tab key, you can see a list of the available magic functions. You could write your own magic functions too, but that’s a little bit outside of the scope of this course.</p>
<p>Here, we’re actually going to use what’s called a <strong>cellular magic function</strong>. These start with two percentage signs and wrap the code in the current Jupyter cell. The function we’re going to use is called <code>timeit</code>. This function will run our code a few times to determine, on average, how long it takes.</p>
<p>Let’s run timeit with our original iterative code. You can give timeit the number of loops that you would like to run. By default, it is 1,000 loops. I’ll ask timeit here to use 100 runs because we’re recording this. Note that in order to use a cellular magic function, it has to be the first line in the cell</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>timeit <span class="op">-</span>n <span class="dv">100</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> number <span class="kw">in</span> numbers:</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    total <span class="op">+=</span> number</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>total<span class="op">/</span><span class="bu">len</span>(numbers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1.14 ms ± 22.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>timeit <span class="op">-</span>n <span class="dv">100</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> np.<span class="bu">sum</span>(numbers)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>total<span class="op">/</span><span class="bu">len</span>(numbers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>53.3 µs ± 3.61 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>
</div>
</div>
<p>This is a pretty shocking difference in the speed and demonstrates why one should be aware of parallel computing features and start thinking in functional programming terms.</p>
<p>Put more simply, vectorization is the ability for a computer to execute multiple instructions at once, and with high performance chips, especially graphics cards, you can get dramatic speedups. Modern graphics cards can run thousands of instructions in parallel.</p>
<p>A Related feature in pandas and nummy is called <strong>broadcasting.</strong> With broadcasting, you can apply an operation to every value in the series, changing the series. For instance, if we wanted to increase every random variable by 2, we could do so quickly using the += operator directly on the Series object.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>numbers.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>0    368
1    720
2    203
3    686
4    962
dtype: int64</code></pre>
</div>
</div>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">+=</span> <span class="dv">2</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>numbers.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>0    370
1    722
2    205
3    688
4    964
dtype: int64</code></pre>
</div>
</div>
<p>The procedural way of doing this would be to iterate through all of the items in the series and increase the values directly. Pandas does support iterating through a series much like a dictionary, allowing you to unpack values easily.</p>
<p>We can use the <code>iteritems()</code> function which returns a label and value</p>
<p>Pandas.iat(): allows to access a single value for a row/column pair by integer position.</p>
<p>Selection with .at is nearly identical to .loc but it only selects a single ‘cell’ in your DataFrame/Series. We usually refer to this cell as a scalar value.</p>
<ul>
<li>loc: label based, only works on index</li>
<li>iloc: position based</li>
<li>at: label based, gets scalar values. It’s a very fast loc; Cannot operate on array indexers. Can assign new indices and columns</li>
<li>iat: position based, gets scalar values. It’s a very fast iloc, Cannot work in array indexers. Cannot! assign new indices and columns.</li>
</ul>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, value <span class="kw">in</span> numbers.iteritems():</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># in the early version of pandas we would use the set_value() function</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># in the current version, we use the iat() or at() functions,</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    numbers.iat[label] <span class="op">=</span> value <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">#numbers.iloc[label] = value + 2</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>numbers.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>0    372
1    724
2    207
3    690
4    966
dtype: int64</code></pre>
</div>
</div>
<p>Let’s compare the speed:</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>timeit <span class="op">-</span>n <span class="dv">10</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co"># we'll create a blank new series of items to deal with</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(np.random.randint(<span class="dv">0</span>,<span class="dv">1000</span>,<span class="dv">1000</span>))</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co"># And we'll just rewrite our loop from above.</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, value <span class="kw">in</span> s.iteritems():</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    s.loc[label]<span class="op">=</span> value<span class="op">+</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>44.5 ms ± 5.17 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>timeit <span class="op">-</span>n <span class="dv">10</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co"># We need to recreate a series</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(np.random.randint(<span class="dv">0</span>,<span class="dv">1000</span>,<span class="dv">1000</span>))</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="co"># And we just broadcast with +=</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>s<span class="op">+=</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>255 µs ± 89.2 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</code></pre>
</div>
</div>
<p>Not only is it significantly faster, but it’s more concise and even easier to read too. The typical mathematical operations you would expect are vectorized, and the nump documentation outlines what it takes to create vectorized functions of your own</p>
<p>One last note on using the indexing operators to access series data. **The .loc attribute lets you not only modify data in place, but also add new data as well((. If the value you pass in as the index doesn’t exist, then a new entry is added. And keep in mind, indices can have mixed types. While it’s important to be aware of the typing going on underneath, Pandas will automatically change the underlying NumPy types as appropriate.</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co">#add a new value</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>s.loc[<span class="st">'History'</span>] <span class="op">=</span> <span class="dv">102</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>0            1
1            2
2            3
History    102
dtype: int64</code></pre>
</div>
</div>
<p>We see that mixed types for data values or index labels are no problem for Pandas. Since “History” is not in the original list of indices, s.loc[‘History’] essentially creates a new element in the series, with the index named “History”, and the value of 102</p>
<p>Up until now I’ve shown only examples of a series where the index values were unique. I want to end this lecture by showing an example where index values are not unique, and this makes pandas Series a little different conceptually then, for instance, a relational database.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Lets create a Series with students and the courses which they have taken</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>students_classes <span class="op">=</span> pd.Series({<span class="st">'Alice'</span>: <span class="st">'Physics'</span>,</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Jack'</span>: <span class="st">'Chemistry'</span>,</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Molly'</span>: <span class="st">'English'</span>,</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Sam'</span>: <span class="st">'History'</span>})</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>students_classes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>Alice      Physics
Jack     Chemistry
Molly      English
Sam        History
dtype: object</code></pre>
</div>
</div>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Now lets create a Series just for some new student Kelly, which lists all of the courses she has taken.</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="co">#We'll set the index to Kelly, and the data to be the names of courses.</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>kelly_classes <span class="op">=</span> pd.Series([<span class="st">'Philosophy'</span>, <span class="st">'Arts'</span>, <span class="st">'Math'</span>], index<span class="op">=</span>[<span class="st">'Kelly'</span>, <span class="st">'Kelly'</span>, <span class="st">'Kelly'</span>])</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>kelly_classes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>Kelly    Philosophy
Kelly          Arts
Kelly          Math
dtype: object</code></pre>
</div>
</div>
</section>
<section id="appending-series" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="appending-series"><span class="header-section-number">5.5</span> Appending Series</h2>
<p>Finally, we can append all of the data in this new Series to the first using the <code>.append()</code> function.</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>all_students_classes <span class="op">=</span> students_classes.append(kelly_classes)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>all_students_classes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>Alice       Physics
Jack      Chemistry
Molly       English
Sam         History
Kelly    Philosophy
Kelly          Arts
Kelly          Math
dtype: object</code></pre>
</div>
</div>
<p>There are a couple of important considerations when using append.</p>
<ul>
<li>First, Pandas will take the series and try to infer the best data types to use. In this example, everything is a string, so there’s no problems here.</li>
<li>Second, the append method doesn’t actually change the underlying Series objects, it instead returns a new series which is made up of the two appended together. This is a common pattern in pandas - by default returning a new object instead of modifying in place - and one you should come to expect. By printing the original series we can see that that series hasn’t changed.</li>
</ul>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>students_classes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>Alice      Physics
Jack     Chemistry
Molly      English
Sam        History
dtype: object</code></pre>
</div>
</div>
<p>Finally, we see that when we query the appended series for Kelly, we don’t get a single value, but a series itself.</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>all_students_classes[<span class="st">'Kelly'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>Kelly    Philosophy
Kelly          Arts
Kelly          Math
dtype: object</code></pre>
</div>
</div>
</section>
<section id="dataframes" class="level2" data-number="5.6">
<h2 data-number="5.6" class="anchored" data-anchor-id="dataframes"><span class="header-section-number">5.6</span> Dataframes</h2>
<p>The DataFrame data structure is the heart of the Panda’s library. It’s a primary object that you’ll be working with in data analysis and cleaning tasks.</p>
<p>The DataFrame is conceptually a two-dimensional series object, where there’s an index and multiple columns of content, with each column having a label. In fact, the distinction between a column and a row is really only a conceptual distinction. And you can think of the DataFrame itself as simply a two-axes labeled array.</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>record1 <span class="op">=</span> pd.Series({<span class="st">'Name'</span>: <span class="st">'Alice'</span>,</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Class'</span>: <span class="st">'Physics'</span>,</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Score'</span>: <span class="dv">85</span>})</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>record2 <span class="op">=</span> pd.Series({<span class="st">'Name'</span>: <span class="st">'Jack'</span>,</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Class'</span>: <span class="st">'Chemistry'</span>,</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Score'</span>: <span class="dv">82</span>})</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>record3 <span class="op">=</span> pd.Series({<span class="st">'Name'</span>: <span class="st">'Helen'</span>,</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Class'</span>: <span class="st">'Biology'</span>,</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'Score'</span>: <span class="dv">90</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Like a Series, the DataFrame object is index. Here I’ll use a group of series, where each series represents a row of data. Just like the Series function, we can pass in our individual items in an array, and we can pass in our index values as a second arguments</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame([record1, record2, record3],</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> [<span class="st">'school1'</span>, <span class="st">'school2'</span>, <span class="st">'school1'</span>])</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Class</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Alice</td>
      <td>Physics</td>
      <td>85</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>Jack</td>
      <td>Chemistry</td>
      <td>82</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Helen</td>
      <td>Biology</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>You’ll notice here that Jupyter creates a nice bit of HTML to render the results of the dataframe. So we have the index, which is the leftmost column and is the school name, and then we have the rows of data, where each row has a column header which was given in our initial record dictionaries.</p>
<p>An alternative method is that you could use a list of dictionaries, where each dictionary represents a row of data.</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>students <span class="op">=</span> [{<span class="st">'Name'</span>: <span class="st">'Alice'</span>,</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>              <span class="st">'Class'</span>: <span class="st">'Physics'</span>,</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>              <span class="st">'Score'</span>: <span class="dv">85</span>},</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>            {<span class="st">'Name'</span>: <span class="st">'Jack'</span>,</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>             <span class="st">'Class'</span>: <span class="st">'Chemistry'</span>,</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>             <span class="st">'Score'</span>: <span class="dv">82</span>},</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>            {<span class="st">'Name'</span>: <span class="st">'Helen'</span>,</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>             <span class="st">'Class'</span>: <span class="st">'Biology'</span>,</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>             <span class="st">'Score'</span>: <span class="dv">90</span>}]</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Then we pass this list of dictionaries into the DataFrame function</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(students, index<span class="op">=</span>[<span class="st">'school1'</span>, <span class="st">'school2'</span>, <span class="st">'school1'</span>])</span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a><span class="co"># And lets print the head again</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Class</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Alice</td>
      <td>Physics</td>
      <td>85</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>Jack</td>
      <td>Chemistry</td>
      <td>82</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Helen</td>
      <td>Biology</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Similar to the series, we can extract data using the <code>.iloc</code> and <code>.loc</code> attributes. Because the DataFrame is two-dimensional, passing a single value to the loc indexing operator will return the series if there’s only one row to return.</p>
<p>For instance, if we wanted to select data associated with school2, we would just query the .loc attribute with one parameter.</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>df.loc[<span class="st">'school2'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="44">
<pre><code>Name          Jack
Class    Chemistry
Score           82
Name: school2, dtype: object</code></pre>
</div>
</div>
<p>You’ll note that the name of the series is returned as the index value, while the column name is included in the output. We can check the data type of the return using the python type function.</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(df.loc[<span class="st">'school2'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre><code>pandas.core.series.Series</code></pre>
</div>
</div>
<p>It’s important to remember that the indices and column names along either axes horizontal or vertical, could be non-unique. In this example, we see two records for school1 as different rows.</p>
<p>If we use a single value with the DataFrame lock attribute, multiple rows of the DataFrame will return, not as a new series, but as a new DataFrame.</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>df.loc[<span class="st">'school1'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="46">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Class</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Alice</td>
      <td>Physics</td>
      <td>85</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Helen</td>
      <td>Biology</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># And we can see the the type of this is different too</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(df.loc[<span class="st">'school1'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>pandas.core.frame.DataFrame</code></pre>
</div>
</div>
<p>One of the powers of the Panda’s DataFrame is that you can quickly select data based on multiple axes.For instance, if you wanted to just list the student names for school1, you would supply two parameters to .loc, one being the row index and the other being the column name.</p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>df.loc[<span class="st">'school1'</span>, <span class="st">'Name'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre><code>school1    Alice
school1    Helen
Name: Name, dtype: object</code></pre>
</div>
</div>
<p>Remember, just like the Series, the pandas developers have implemented this using the indexing operator and not as parameters to a function.</p>
<p>What would we do if we just wanted to select a single column though? Well, there are a few mechanisms. Firstly, we could transpose the matrix. This pivots all of the rows into columns and all of the columns into rows, and is done with the <strong>T attribute</strong></p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>df.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="49">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>school1</th>
      <th>school2</th>
      <th>school1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Name</th>
      <td>Alice</td>
      <td>Jack</td>
      <td>Helen</td>
    </tr>
    <tr>
      <th>Class</th>
      <td>Physics</td>
      <td>Chemistry</td>
      <td>Biology</td>
    </tr>
    <tr>
      <th>Score</th>
      <td>85</td>
      <td>82</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Then we can call .loc on the transpose to get the student names only</p>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>df.T.loc[<span class="st">'Name'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>school1    Alice
school2     Jack
school1    Helen
Name: Name, dtype: object</code></pre>
</div>
</div>
<p>However, since iloc and loc are used for row selection, Panda reserves the indexing operator directly on the DataFrame for column selection. In a Panda’s DataFrame, columns always have a name.</p>
<p>So this selection is always label based, and is not as confusing as it was when using the square bracket operator on the series objects. For those familiar with relational databases, this operator is analogous to column projection.</p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Name'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<pre><code>school1    Alice
school2     Jack
school1    Helen
Name: Name, dtype: object</code></pre>
</div>
</div>
<p>In practice, this works really well since you’re often trying to add or drop new columns. However, this also means that you get a key error if you try and use .loc with a column name:</p>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co">#this gives an error:</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="co">#df.loc['Name']</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note too that the result of a single column projection is a Series object.</p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(df[<span class="st">'Name'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<pre><code>pandas.core.series.Series</code></pre>
</div>
</div>
<p>Since the result of using the indexing operator is either a DataFrame or Series, you can chain operations together. For instance, we can select all of the rows which related to school1 using .loc, then project the name column from just those rows.</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>df.loc[<span class="st">'school1'</span>][<span class="st">'Name'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>school1    Alice
school1    Helen
Name: Name, dtype: object</code></pre>
</div>
</div>
<p>If you get confused, use type to check the responses from resulting operations</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">type</span>(df.loc[<span class="st">'school1'</span>])) <span class="co">#should be a DataFrame</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">type</span>(df.loc[<span class="st">'school1'</span>][<span class="st">'Name'</span>])) <span class="co">#should be a Series</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
&lt;class 'pandas.core.series.Series'&gt;</code></pre>
</div>
</div>
<p>Chaining, by indexing on the return type of another index, can come with some costs and is best avoided if you can use another approach. In particular, chaining tends to cause Pandas to return a copy of the DataFrame instead of a view on the DataFrame. For selecting data, this is not a big deal, though it might be slower than necessary. If you are changing data though this is an important distinction and can be a source of error.</p>
<p>Here’s another approach. As we saw, .loc does row selection, and it can take two parameters, the row index and the list of column names. The .loc attribute also supports slicing.</p>
<p>If we wanted to select all rows, we can use a colon to indicate a full slice from beginning to end. This is just like slicing characters in a list in python. Then we can add the column name as the second parameter as a string. If we wanted to include multiple columns, we could do so in a list. and Pandas will bring back only the columns we have asked for.</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>df.loc[:,[<span class="st">'Name'</span>, <span class="st">'Score'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Alice</td>
      <td>85</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>Jack</td>
      <td>82</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Helen</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Take a look at that again. The colon means that we want to get all of the rows, and the list in the second argument position is the list of columns we want to get back.</p>
</section>
<section id="dropping-data" class="level2" data-number="5.7">
<h2 data-number="5.7" class="anchored" data-anchor-id="dropping-data"><span class="header-section-number">5.7</span> Dropping data</h2>
<p>Before we leave the discussion of accessing data in DataFrames, lets talk about dropping data.</p>
<p>It’s easy to delete data in Series and DataFrames, and we can use the <strong>drop function</strong> to do so. This function takes a single parameter, which is the index or row label, to drop.</p>
<p>This is another tricky place for new users – the drop function doesn’t change the DataFrame by default! Instead,the drop function returns to you a copy of the DataFrame with the given rows removed.</p>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>df.drop(<span class="st">'school1'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Class</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school2</th>
      <td>Jack</td>
      <td>Chemistry</td>
      <td>82</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="58">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Class</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Alice</td>
      <td>Physics</td>
      <td>85</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>Jack</td>
      <td>Chemistry</td>
      <td>82</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Helen</td>
      <td>Biology</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Drop has two interesting optional parameters:</p>
<ul>
<li>The first is called inplace, and if it’s set to true, the DataFrame will be updated in place, instead of a copy being returned.<br>
</li>
<li>The second parameter is the axes, which should be dropped. By default, this value is 0, indicating the row axis. But you could change it to 1 if you want to drop a column.</li>
</ul>
<p>For example, lets make a copy of a DataFrame using <strong>.copy()</strong>:</p>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>copy_df <span class="op">=</span> df.copy()</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="co">#drop the name column of the copy</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>copy_df.drop(<span class="st">'Name'</span>, inplace <span class="op">=</span> <span class="va">True</span>, axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>copy_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="59">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Class</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Physics</td>
      <td>85</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>Chemistry</td>
      <td>82</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Biology</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="60">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Class</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Alice</td>
      <td>Physics</td>
      <td>85</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>Jack</td>
      <td>Chemistry</td>
      <td>82</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Helen</td>
      <td>Biology</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>There is a second way to drop a column, and that’s directly through the use of the indexing operator, using the <strong>del keyword</strong>. This way of dropping data, however, takes immediate effect on the DataFrame and does not return a view.</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span> copy_df[<span class="st">'Class'</span>]</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>copy_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="61">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>85</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>82</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
<section id="adding-columns-to-a-df" class="level2" data-number="5.8">
<h2 data-number="5.8" class="anchored" data-anchor-id="adding-columns-to-a-df"><span class="header-section-number">5.8</span> Adding columns to a df</h2>
<p>Adding a new column to the DataFrame is as easy as assigning it to some value using the indexing operator. For instance, if we wanted to add a class ranking column with default value of None, we could do so by using the assignment operator after the square brackets. This broadcasts the default value to the new column immediately.</p>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'ClassRanking'</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="62">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Name</th>
      <th>Class</th>
      <th>Score</th>
      <th>ClassRanking</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>school1</th>
      <td>Alice</td>
      <td>Physics</td>
      <td>85</td>
      <td>None</td>
    </tr>
    <tr>
      <th>school2</th>
      <td>Jack</td>
      <td>Chemistry</td>
      <td>82</td>
      <td>None</td>
    </tr>
    <tr>
      <th>school1</th>
      <td>Helen</td>
      <td>Biology</td>
      <td>90</td>
      <td>None</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
<section id="dataframe-indexing-and-loading" class="level2" data-number="5.9">
<h2 data-number="5.9" class="anchored" data-anchor-id="dataframe-indexing-and-loading"><span class="header-section-number">5.9</span> DataFrame Indexing and Loading</h2>
<p>A common workflow is to read the dataset in, usually from some external file, then begin to clean and manipulate the dataset for analysis. In this lecture I’m going to demonstrate how you can load data from a comma separated file into a DataFrame.</p>
<p>Lets just jump right in and talk about comma separated values (csv) files.</p>
<p>Now, I’m going to make a quick aside because it’s convenient here. The Jupyter notebooks use ipython as the kernel underneath, which provides convenient ways to integrate lower level shell commands, which are programs run in the underlying operating system. If you’re not familiar with the shell don’t worry too much about this, but if you are, this is super handy for integration of your data science workflows.</p>
<p>I want to use one shell command here called “cat”, for “concatenate”, which just outputs the contents of a file. In ipython if we prepend the line with an exclamation mark it will execute the remainder of the line as a shell command. So lets look at the content of a CSV file.</p>
<p>Notice: Instead of cat, we use head to use head to display the first 10 rows.</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>head ..<span class="op">/</span>data<span class="op">/</span>week2<span class="op">/</span>Admission_Predict.csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Serial No.,GRE Score,TOEFL Score,University Rating,SOP,LOR ,CGPA,Research,Chance of Admit 
1,337,118,4,4.5,4.5,9.65,1,0.92
2,324,107,4,4,4.5,8.87,1,0.76
3,316,104,3,3,3.5,8,1,0.72
4,322,110,3,3.5,2.5,8.67,1,0.8
5,314,103,2,2,3,8.21,0,0.65
6,330,115,5,4.5,3,9.34,1,0.9
7,321,109,3,3,4,8.2,1,0.75
8,308,101,2,3,4,7.9,0,0.68
9,302,102,1,2,1.5,8,0,0.5</code></pre>
</div>
</div>
<p>We see from the output that there is a list of columns, and the column identifiers are listed as strings on the first line of the file. Then we have rows of data, all columns separated by commas. We can read in this file using pandas.</p>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="co">#turn csv into a dataframe</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/Admission_Predict.csv'</span>)</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Serial No.</th>
      <th>GRE Score</th>
      <th>TOEFL Score</th>
      <th>University Rating</th>
      <th>SOP</th>
      <th>LOR</th>
      <th>CGPA</th>
      <th>Research</th>
      <th>Chance of Admit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>0.65</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>We notice that by default index starts with 0 while the students’ serial number starts from 1. If you jump back to the CSV output you’ll deduce that pandas has create a new index. Instead, we can set the serial no as the index if we want to by using the index_col.</p>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/Admission_Predict.csv'</span>, index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>GRE Score</th>
      <th>TOEFL Score</th>
      <th>University Rating</th>
      <th>SOP</th>
      <th>LOR</th>
      <th>CGPA</th>
      <th>Research</th>
      <th>Chance of Admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>5</th>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>0.65</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
<section id="renaming-columns-in-a-df" class="level2" data-number="5.10">
<h2 data-number="5.10" class="anchored" data-anchor-id="renaming-columns-in-a-df"><span class="header-section-number">5.10</span> Renaming columns in a df</h2>
<p>Notice that we have two columns “SOP” and “LOR” and probably not everyone knows what they mean So let’s change our column names to make it more clear. In Pandas, we can use the <strong>rename() function</strong>.</p>
<p>It takes a parameter called columns, and we need to pass into a dictionary which the keys are the old column name and the value is the corresponding new column name:</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>new_df<span class="op">=</span>df.rename(columns<span class="op">=</span>{<span class="st">'GRE Score'</span>:<span class="st">'GRE Score'</span>, <span class="st">'TOEFL Score'</span>:<span class="st">'TOEFL Score'</span>,</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'University Rating'</span>:<span class="st">'University Rating'</span>, </span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'SOP'</span>: <span class="st">'Statement of Purpose'</span>,<span class="st">'LOR'</span>: <span class="st">'Letter of Recommendation'</span>,</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'CGPA'</span>:<span class="st">'CGPA'</span>, <span class="st">'Research'</span>:<span class="st">'Research'</span>,</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Chance of Admit'</span>:<span class="st">'Chance of Admit'</span>})</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>new_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="66">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>GRE Score</th>
      <th>TOEFL Score</th>
      <th>University Rating</th>
      <th>Statement of Purpose</th>
      <th>LOR</th>
      <th>CGPA</th>
      <th>Research</th>
      <th>Chance of Admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>5</th>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>0.65</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>From the output, we can see that only “SOP” is changed but not “LOR” Why is that? Let’s investigate this a bit. First we need to make sure we got all the column names correct. We can use the columns attribute of dataframe to get a list.</p>
<div class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>new_df.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="67">
<pre><code>Index(['GRE Score', 'TOEFL Score', 'University Rating', 'Statement of Purpose',
       'LOR ', 'CGPA', 'Research', 'Chance of Admit '],
      dtype='object')</code></pre>
</div>
</div>
<p>If we look at the output closely, we can see that there is actually a space right after “LOR” and a space right after “Chance of Admit”. So this is why our rename dictionary does not work for LOR, because the key we used was just three characters, instead of four characters in “LOR”</p>
<p>There are a couple of ways we could address this. One way would be to change a column by including the space in the name:</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>new_df <span class="op">=</span> new_df.rename(columns <span class="op">=</span> {<span class="st">'LOR '</span>: <span class="st">'Letter of Recommendation'</span>})</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>new_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>GRE Score</th>
      <th>TOEFL Score</th>
      <th>University Rating</th>
      <th>Statement of Purpose</th>
      <th>Letter of Recommendation</th>
      <th>CGPA</th>
      <th>Research</th>
      <th>Chance of Admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>5</th>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>0.65</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>So that works well, but it’s a bit fragile. What if that was a tab instead of a space? Or two spaces?</p>
<p>Another way is to create some function that does the cleaning and then tell renamed to apply that function across all of the data. Python comes with a handy string function to strip white space called <strong>strip()</strong>.</p>
<p>When we pass this in to rename we pass the function as the mapper parameter, and then indicate whether the axis should be columns or index (row labels)</p>
<div class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>new_df<span class="op">=</span>new_df.rename(mapper<span class="op">=</span><span class="bu">str</span>.strip, axis<span class="op">=</span><span class="st">'columns'</span>)</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>new_df.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre><code>Index(['GRE Score', 'TOEFL Score', 'University Rating', 'Statement of Purpose',
       'Letter of Recommendation', 'CGPA', 'Research', 'Chance of Admit'],
      dtype='object')</code></pre>
</div>
</div>
<p>Now we’ve got it - both SOP and LOR have been renamed and Chance of Admit has been trimmed up. Remember though that the rename function isn’t modifying the dataframe. In this case, df is the same as it always was, there’s just a copy in new_df with the changed names.</p>
<div class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>df.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>Index(['GRE Score', 'TOEFL Score', 'University Rating', 'SOP', 'LOR ', 'CGPA',
       'Research', 'Chance of Admit '],
      dtype='object')</code></pre>
</div>
</div>
<p>We can also use the df.columns attribute by assigning to it a list of column names which will directly rename the columns. This will directly modify the original dataframe and is very efficient especially when you have a lot of columns and you only want to change a few. This technique is also not affected by subtle errors in the column names, a problem that we just encountered. With a list, you can use the list index to change a certain value or use list comprehension to change all of the values</p>
<p>As an example, lets change all of the column names to lower case. First we need to get our list:</p>
<div class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="co">#get a list of our column names</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> <span class="bu">list</span>(df.columns)</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>cols</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre><code>['GRE Score',
 'TOEFL Score',
 'University Rating',
 'SOP',
 'LOR ',
 'CGPA',
 'Research',
 'Chance of Admit ']</code></pre>
</div>
</div>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="co">#do some cleanup via list comprehension</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [x.lower().strip() <span class="cf">for</span> x <span class="kw">in</span> cols]</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>cols</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>['gre score',
 'toefl score',
 'university rating',
 'sop',
 'lor',
 'cgpa',
 'research',
 'chance of admit']</code></pre>
</div>
</div>
<div class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="co">#overwrite the columns in our df</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>df.columns <span class="op">=</span> cols</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
      <th>university rating</th>
      <th>sop</th>
      <th>lor</th>
      <th>cgpa</th>
      <th>research</th>
      <th>chance of admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>5</th>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>0.65</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
<section id="querying-a-dataframe" class="level2" data-number="5.11">
<h2 data-number="5.11" class="anchored" data-anchor-id="querying-a-dataframe"><span class="header-section-number">5.11</span> Querying a dataframe</h2>
<p>In this lecture we’re going to talk about querying DataFrames. The first step in the process is to understand Boolean masking. Boolean masking is the heart of fast and efficient querying in numpy and pandas, and it’s analogous to bit masking used in other areas of computational science.</p>
<section id="boolean-masking" class="level3" data-number="5.11.1">
<h3 data-number="5.11.1" class="anchored" data-anchor-id="boolean-masking"><span class="header-section-number">5.11.1</span> Boolean masking</h3>
<p>A <strong>Boolean mask</strong> is an array which can be of one dimension like a series, or two dimensions like a data frame, where each of the values in the array are either true or false. This array is essentially overlaid on top of the data structure that we’re querying. And any cell aligned with the true value will be admitted into our final result, and any cell aligned with a false value will not.</p>
<div class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a><span class="co">#read in df</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/Admission_Predict.csv'</span>, index_col <span class="op">=</span> <span class="dv">0</span>)</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a><span class="co">#do cleanup</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>df.columns <span class="op">=</span> [x.lower().strip() <span class="cf">for</span> x <span class="kw">in</span> df.columns]</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
      <th>university rating</th>
      <th>sop</th>
      <th>lor</th>
      <th>cgpa</th>
      <th>research</th>
      <th>chance of admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>5</th>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>0.65</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Boolean masks are created by applying operators directly to the pandas Series or DataFrame objects.</p>
<p>For instance, in our graduate admission dataset, we might be interested in seeing only those students that have a chance higher than 0.7 at being admitted.</p>
<p>To build a Boolean mask for this query, we want to project the chance of admit column using the indexing operator and apply the greater than operator with a comparison value of 0.7.</p>
<p>This is essentially broadcasting a comparison operator, greater than, with the results being returned as a Boolean Series. The resultant Series is indexed where the value of each cell is either True or False depending on whether a student has a chance of admit higher than 0.7.</p>
<div class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>admit_mask <span class="op">=</span> df[<span class="st">'chance of admit'</span>] <span class="op">&gt;</span> <span class="fl">0.7</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>admit_mask</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>Serial No.
1       True
2       True
3       True
4       True
5      False
       ...  
396     True
397     True
398     True
399    False
400     True
Name: chance of admit, Length: 400, dtype: bool</code></pre>
</div>
</div>
<p><strong>The result of broadcasting a comparison operator is a Boolean mask</strong> - true or false values depending upon the results of the comparison.</p>
<p>Underneath, pandas is applying the comparison operator you specified through vectorization (so efficiently and in parallel) to all of the values in the array you specified which, in this case, is the chance of admit column of the dataframe.</p>
<p>The result is a series, since only one column is being operator on, filled with either True or False values, which is what the comparison operator returns.</p>
<p>So, what do you do with the boolean mask once you have formed it? Well, you can just lay it on top of the data to “hide” the data you don’t want, which is represented by all of the False values. We do this by using the <strong>.where()</strong> function on the original DataFrame.</p>
<div class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>df.where(admit_mask).head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
      <th>university rating</th>
      <th>sop</th>
      <th>lor</th>
      <th>cgpa</th>
      <th>research</th>
      <th>chance of admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337.0</td>
      <td>118.0</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1.0</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324.0</td>
      <td>107.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1.0</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316.0</td>
      <td>104.0</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1.0</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322.0</td>
      <td>110.0</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1.0</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>We see that the resulting data frame keeps the original indexed values, and only data which met the condition was retained. All of the rows which did not meet the condition have NaN data instead, but these rows were not dropped from our dataset.</p>
<p>The next step is, if we don’t want the NaN data, we use the <strong>dropna()</strong> function:</p>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>df.where(admit_mask).dropna().head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
      <th>university rating</th>
      <th>sop</th>
      <th>lor</th>
      <th>cgpa</th>
      <th>research</th>
      <th>chance of admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337.0</td>
      <td>118.0</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1.0</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324.0</td>
      <td>107.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1.0</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316.0</td>
      <td>104.0</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1.0</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322.0</td>
      <td>110.0</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1.0</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>6</th>
      <td>330.0</td>
      <td>115.0</td>
      <td>5.0</td>
      <td>4.5</td>
      <td>3.0</td>
      <td>9.34</td>
      <td>1.0</td>
      <td>0.90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>The returned DataFrame now has all of the NaN rows dropped. Notice the index now includes one through four and six, but not five.</p>
<p>Despite being really handy, where() isn’t actually used that often. Instead, the pandas devs created a shorthand syntax which combines where() and dropna(), doing both at once. And, in typical fashion, they just overloaded the indexing operator to do this.</p>
<div class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>df[df[<span class="st">'chance of admit'</span>] <span class="op">&gt;</span> <span class="fl">0.7</span>].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
      <th>university rating</th>
      <th>sop</th>
      <th>lor</th>
      <th>cgpa</th>
      <th>research</th>
      <th>chance of admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>6</th>
      <td>330</td>
      <td>115</td>
      <td>5</td>
      <td>4.5</td>
      <td>3.0</td>
      <td>9.34</td>
      <td>1</td>
      <td>0.90</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Just reviewing this indexing operator on DataFrame, it now does three things. First, it can be called with a string parameter to project a single column:</p>
<div class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'gre score'</span>].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="79">
<pre><code>Serial No.
1    337
2    324
3    316
4    322
5    314
Name: gre score, dtype: int64</code></pre>
</div>
</div>
<p>Or you can send it a list of columns as strings:</p>
<div class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>df[[<span class="st">'gre score'</span>, <span class="st">'toefl score'</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="80">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
    </tr>
    <tr>
      <th>5</th>
      <td>314</td>
      <td>103</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Or you can send it a boolean mask:</p>
<div class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>df[df[<span class="st">'gre score'</span>] <span class="op">&gt;</span> <span class="dv">320</span>].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
      <th>university rating</th>
      <th>sop</th>
      <th>lor</th>
      <th>cgpa</th>
      <th>research</th>
      <th>chance of admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>6</th>
      <td>330</td>
      <td>115</td>
      <td>5</td>
      <td>4.5</td>
      <td>3.0</td>
      <td>9.34</td>
      <td>1</td>
      <td>0.90</td>
    </tr>
    <tr>
      <th>7</th>
      <td>321</td>
      <td>109</td>
      <td>3</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>8.20</td>
      <td>1</td>
      <td>0.75</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>And each of these is mimicing functionality from either .loc() or .where().dropna().</p>
<p>Before we leave this, lets talk about combining multiple boolean masks, such as multiple criteria for including. In bitmasking in other places in computer science this is done with “and”, if both masks must be True for a True value to be in the final mask), or “or” if only one needs to be True. Unfortunatly, it doesn’t feel quite as natural in pandas. For instance, if you want to take two boolean series and and them together:</p>
<div class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="co">#this gives an error</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="co">#(df['chance of admit'] &gt; 0.7) and (df['chance of admit'] &lt; 0.9)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The problem is that you have series objects, and python underneath doesn’t know how to compare two series using and or or. Instead, the pandas authors have overwritten the pipe | and ampersand &amp; operators to handle this for us:</p>
<div class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>df[(df[<span class="st">'chance of admit'</span>] <span class="op">&gt;</span> <span class="fl">0.7</span>) <span class="op">&amp;</span> (df[<span class="st">'chance of admit'</span>] <span class="op">&lt;</span> <span class="fl">0.9</span>)].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="83">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gre score</th>
      <th>toefl score</th>
      <th>university rating</th>
      <th>sop</th>
      <th>lor</th>
      <th>cgpa</th>
      <th>research</th>
      <th>chance of admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>7</th>
      <td>321</td>
      <td>109</td>
      <td>3</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>8.20</td>
      <td>1</td>
      <td>0.75</td>
    </tr>
    <tr>
      <th>12</th>
      <td>327</td>
      <td>111</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>9.00</td>
      <td>1</td>
      <td>0.84</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>One thing to watch out for is order of operations! A common error for new pandas users is to try and do boolean comparisons using the &amp; operator but not putting parentheses around the individual terms you are interested in:</p>
<pre><code>df['chance of admit'] &gt; 0.7 &amp; df['chance of admit'] &lt; 0.9</code></pre>
<p>The problem is that Python is trying to bitwise <code>and</code>, a 0.7 and a pandas dataframe, when you really want to bitwise and the broadcasted dataframes together.</p>
<p>Another way to do this is to just get rid of the comparison operator completely, and instead use the built in functions which mimic this approach:</p>
<div class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'chance of admit'</span>].gt(<span class="fl">0.7</span>) <span class="op">&amp;</span> df[<span class="st">'chance of admit'</span>].lt(<span class="fl">0.9</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="84">
<pre><code>Serial No.
1      False
2       True
3       True
4       True
5      False
       ...  
396     True
397     True
398    False
399    False
400    False
Name: chance of admit, Length: 400, dtype: bool</code></pre>
</div>
</div>
<p>These functions are build right into the Series and DataFrame objects, so you can chain them too, which results in the same answer and the use of no visual operators. You can decide what looks best for you.</p>
<div class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'chance of admit'</span>].gt(<span class="fl">0.7</span>).lt(<span class="fl">0.9</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="85">
<pre><code>Serial No.
1      False
2      False
3      False
4      False
5       True
       ...  
396    False
397    False
398    False
399     True
400    False
Name: chance of admit, Length: 400, dtype: bool</code></pre>
</div>
</div>
<p>This only works if your operator, such as less than or greater than, is built into the DataFrame, but I certainly find that last code example much more readable than one with ampersands and parenthesis.</p>
<p>You need to be able to read and write all of these, and understand the implications of the route you are choosing. It’s worth really going back and rewatching this lecture to make sure you have it. I would say 50% or more of the work you’ll be doing in data cleaning involves querying DataFrames.</p>
</section>
</section>
<section id="indexing-dataframes" class="level2" data-number="5.12">
<h2 data-number="5.12" class="anchored" data-anchor-id="indexing-dataframes"><span class="header-section-number">5.12</span> Indexing dataframes</h2>
<p>As we’ve seen, both Series and DataFrames can have indices applied to them. The index is essentially a row level label, and in pandas the rows correspond to axis zero.</p>
<p>Indices can either be either autogenerated, such as when we create a new Series without an index, in which case we get numeric values, or they can be set explicitly, like when we use the dictionary object to create the series, or when we loaded data from the CSV file and set appropriate parameters.</p>
<p>Another option for setting an index is to use the set_index() function. This function takes a list of columns and promotes those columns to an index. In this lecture we’ll explore more about how indexes work in pandas.</p>
<div class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/Admission_Predict.csv'</span>, index_col <span class="op">=</span> <span class="dv">0</span>)</span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="86">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>GRE Score</th>
      <th>TOEFL Score</th>
      <th>University Rating</th>
      <th>SOP</th>
      <th>LOR</th>
      <th>CGPA</th>
      <th>Research</th>
      <th>Chance of Admit</th>
    </tr>
    <tr>
      <th>Serial No.</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>0.92</td>
    </tr>
    <tr>
      <th>2</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>0.76</td>
    </tr>
    <tr>
      <th>3</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>0.72</td>
    </tr>
    <tr>
      <th>4</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>0.80</td>
    </tr>
    <tr>
      <th>5</th>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>0.65</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Let’s say that we don’t want to index the DataFrame by serial numbers, but instead by the chance of admit. But lets assume we want to keep the serial number for later. So, lets preserve the serial number into a new column. We can do this using the indexing operator on the string that has the column label. Then we can use the set_index to set index of the column to chance of admit:</p>
<div class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="co">#cp the indexed data into its own column</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Serial Number'</span>] <span class="op">=</span> df.index</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="co">#set the index to another column</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index(<span class="st">'Chance of Admit '</span>)</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="87">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>GRE Score</th>
      <th>TOEFL Score</th>
      <th>University Rating</th>
      <th>SOP</th>
      <th>LOR</th>
      <th>CGPA</th>
      <th>Research</th>
      <th>Serial Number</th>
    </tr>
    <tr>
      <th>Chance of Admit</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0.92</th>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0.76</th>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>0.72</th>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>0.80</th>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>0.65</th>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>You’ll see that when we create a new index from an existing column the index has a name, which is the original name of the column.</p>
<p>We can get rid of the index completely by calling the function <strong>reset_index()</strong>. This promotes the index into a column and creates a default numbered index.</p>
<div class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.reset_index()</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="88">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Chance of Admit</th>
      <th>GRE Score</th>
      <th>TOEFL Score</th>
      <th>University Rating</th>
      <th>SOP</th>
      <th>LOR</th>
      <th>CGPA</th>
      <th>Research</th>
      <th>Serial Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.92</td>
      <td>337</td>
      <td>118</td>
      <td>4</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>9.65</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.76</td>
      <td>324</td>
      <td>107</td>
      <td>4</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>8.87</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.72</td>
      <td>316</td>
      <td>104</td>
      <td>3</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>8.00</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.80</td>
      <td>322</td>
      <td>110</td>
      <td>3</td>
      <td>3.5</td>
      <td>2.5</td>
      <td>8.67</td>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.65</td>
      <td>314</td>
      <td>103</td>
      <td>2</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.21</td>
      <td>0</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>One nice feature of Pandas is <strong>multi-level indexing</strong>. This is similar to composite keys in relational database systems. To create a multi-level index, we simply call set index and give it a list of columns that we’re interested in promoting to an index. Pandas will search through these in order, finding the distinct data and form composite indices.</p>
<p>A good example of this is often found when dealing with geographical data which is sorted by regions or demographics.</p>
<p>Let’s change data sets and look at some census data for a better example. This data is stored in the file census.csv and comes from the United States Census Bureau. In particular, this is a breakdown of the population level data at the US county level. It’s a great example of how different kinds of data sets might be formatted when you’re trying to clean them.</p>
<div class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/census.csv'</span>)</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="89">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>SUMLEV</th>
      <th>REGION</th>
      <th>DIVISION</th>
      <th>STATE</th>
      <th>COUNTY</th>
      <th>STNAME</th>
      <th>CTYNAME</th>
      <th>CENSUS2010POP</th>
      <th>ESTIMATESBASE2010</th>
      <th>POPESTIMATE2010</th>
      <th>...</th>
      <th>RDOMESTICMIG2011</th>
      <th>RDOMESTICMIG2012</th>
      <th>RDOMESTICMIG2013</th>
      <th>RDOMESTICMIG2014</th>
      <th>RDOMESTICMIG2015</th>
      <th>RNETMIG2011</th>
      <th>RNETMIG2012</th>
      <th>RNETMIG2013</th>
      <th>RNETMIG2014</th>
      <th>RNETMIG2015</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>40</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>0</td>
      <td>Alabama</td>
      <td>Alabama</td>
      <td>4779736</td>
      <td>4780127</td>
      <td>4785161</td>
      <td>...</td>
      <td>0.002295</td>
      <td>-0.193196</td>
      <td>0.381066</td>
      <td>0.582002</td>
      <td>-0.467369</td>
      <td>1.030015</td>
      <td>0.826644</td>
      <td>1.383282</td>
      <td>1.724718</td>
      <td>0.712594</td>
    </tr>
    <tr>
      <th>1</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>1</td>
      <td>Alabama</td>
      <td>Autauga County</td>
      <td>54571</td>
      <td>54571</td>
      <td>54660</td>
      <td>...</td>
      <td>7.242091</td>
      <td>-2.915927</td>
      <td>-3.012349</td>
      <td>2.265971</td>
      <td>-2.530799</td>
      <td>7.606016</td>
      <td>-2.626146</td>
      <td>-2.722002</td>
      <td>2.592270</td>
      <td>-2.187333</td>
    </tr>
    <tr>
      <th>2</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>3</td>
      <td>Alabama</td>
      <td>Baldwin County</td>
      <td>182265</td>
      <td>182265</td>
      <td>183193</td>
      <td>...</td>
      <td>14.832960</td>
      <td>17.647293</td>
      <td>21.845705</td>
      <td>19.243287</td>
      <td>17.197872</td>
      <td>15.844176</td>
      <td>18.559627</td>
      <td>22.727626</td>
      <td>20.317142</td>
      <td>18.293499</td>
    </tr>
    <tr>
      <th>3</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>5</td>
      <td>Alabama</td>
      <td>Barbour County</td>
      <td>27457</td>
      <td>27457</td>
      <td>27341</td>
      <td>...</td>
      <td>-4.728132</td>
      <td>-2.500690</td>
      <td>-7.056824</td>
      <td>-3.904217</td>
      <td>-10.543299</td>
      <td>-4.874741</td>
      <td>-2.758113</td>
      <td>-7.167664</td>
      <td>-3.978583</td>
      <td>-10.543299</td>
    </tr>
    <tr>
      <th>4</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>7</td>
      <td>Alabama</td>
      <td>Bibb County</td>
      <td>22915</td>
      <td>22919</td>
      <td>22861</td>
      <td>...</td>
      <td>-5.527043</td>
      <td>-5.068871</td>
      <td>-6.201001</td>
      <td>-0.177537</td>
      <td>0.177258</td>
      <td>-5.088389</td>
      <td>-4.363636</td>
      <td>-5.403729</td>
      <td>0.754533</td>
      <td>1.107861</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 100 columns</p>
</div>
</div>
</div>
<p>In this data set there are two summarized levels (SUMLEV), one that contains summary data for the whole country. And one that contains summary data for each state.</p>
<p>I want to see a list of all the unique values in a given column. In this DataFrame, we see that the possible values for the sum level are using the unique function on the DataFrame. This is similar to the SQL distinct operator.</p>
<p>Here we can run <strong>unique()</strong> on the sum level of our current DataFrame :</p>
<div class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'SUMLEV'</span>].unique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="90">
<pre><code>array([40, 50])</code></pre>
</div>
</div>
<p>We see that there are only two different values, 40 and 50.</p>
<p>Let’s exclude all of the rows that are summaries at the state level and just keep the county data.</p>
<div class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[df[<span class="st">'SUMLEV'</span>] <span class="op">==</span>  <span class="dv">50</span>]</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="91">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>SUMLEV</th>
      <th>REGION</th>
      <th>DIVISION</th>
      <th>STATE</th>
      <th>COUNTY</th>
      <th>STNAME</th>
      <th>CTYNAME</th>
      <th>CENSUS2010POP</th>
      <th>ESTIMATESBASE2010</th>
      <th>POPESTIMATE2010</th>
      <th>...</th>
      <th>RDOMESTICMIG2011</th>
      <th>RDOMESTICMIG2012</th>
      <th>RDOMESTICMIG2013</th>
      <th>RDOMESTICMIG2014</th>
      <th>RDOMESTICMIG2015</th>
      <th>RNETMIG2011</th>
      <th>RNETMIG2012</th>
      <th>RNETMIG2013</th>
      <th>RNETMIG2014</th>
      <th>RNETMIG2015</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>1</td>
      <td>Alabama</td>
      <td>Autauga County</td>
      <td>54571</td>
      <td>54571</td>
      <td>54660</td>
      <td>...</td>
      <td>7.242091</td>
      <td>-2.915927</td>
      <td>-3.012349</td>
      <td>2.265971</td>
      <td>-2.530799</td>
      <td>7.606016</td>
      <td>-2.626146</td>
      <td>-2.722002</td>
      <td>2.592270</td>
      <td>-2.187333</td>
    </tr>
    <tr>
      <th>2</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>3</td>
      <td>Alabama</td>
      <td>Baldwin County</td>
      <td>182265</td>
      <td>182265</td>
      <td>183193</td>
      <td>...</td>
      <td>14.832960</td>
      <td>17.647293</td>
      <td>21.845705</td>
      <td>19.243287</td>
      <td>17.197872</td>
      <td>15.844176</td>
      <td>18.559627</td>
      <td>22.727626</td>
      <td>20.317142</td>
      <td>18.293499</td>
    </tr>
    <tr>
      <th>3</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>5</td>
      <td>Alabama</td>
      <td>Barbour County</td>
      <td>27457</td>
      <td>27457</td>
      <td>27341</td>
      <td>...</td>
      <td>-4.728132</td>
      <td>-2.500690</td>
      <td>-7.056824</td>
      <td>-3.904217</td>
      <td>-10.543299</td>
      <td>-4.874741</td>
      <td>-2.758113</td>
      <td>-7.167664</td>
      <td>-3.978583</td>
      <td>-10.543299</td>
    </tr>
    <tr>
      <th>4</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>7</td>
      <td>Alabama</td>
      <td>Bibb County</td>
      <td>22915</td>
      <td>22919</td>
      <td>22861</td>
      <td>...</td>
      <td>-5.527043</td>
      <td>-5.068871</td>
      <td>-6.201001</td>
      <td>-0.177537</td>
      <td>0.177258</td>
      <td>-5.088389</td>
      <td>-4.363636</td>
      <td>-5.403729</td>
      <td>0.754533</td>
      <td>1.107861</td>
    </tr>
    <tr>
      <th>5</th>
      <td>50</td>
      <td>3</td>
      <td>6</td>
      <td>1</td>
      <td>9</td>
      <td>Alabama</td>
      <td>Blount County</td>
      <td>57322</td>
      <td>57322</td>
      <td>57373</td>
      <td>...</td>
      <td>1.807375</td>
      <td>-1.177622</td>
      <td>-1.748766</td>
      <td>-2.062535</td>
      <td>-1.369970</td>
      <td>1.859511</td>
      <td>-0.848580</td>
      <td>-1.402476</td>
      <td>-1.577232</td>
      <td>-0.884411</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 100 columns</p>
</div>
</div>
</div>
<p>Also while this data set is interesting for a number of different reasons, let’s reduce the data that we’re going to look at to just the total population estimates and the total number of births. We can do this by creating a list of column names that we want to keep then project those and assign the resulting DataFrame to our df variable.</p>
<div class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>columns_to_keep <span class="op">=</span> [<span class="st">'STNAME'</span>,<span class="st">'CTYNAME'</span>,<span class="st">'BIRTHS2010'</span>,<span class="st">'BIRTHS2011'</span>,<span class="st">'BIRTHS2012'</span>,<span class="st">'BIRTHS2013'</span>,</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'BIRTHS2014'</span>,<span class="st">'BIRTHS2015'</span>,<span class="st">'POPESTIMATE2010'</span>,<span class="st">'POPESTIMATE2011'</span>,</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'POPESTIMATE2012'</span>,<span class="st">'POPESTIMATE2013'</span>,<span class="st">'POPESTIMATE2014'</span>,<span class="st">'POPESTIMATE2015'</span>]</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[columns_to_keep]</span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="92">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>STNAME</th>
      <th>CTYNAME</th>
      <th>BIRTHS2010</th>
      <th>BIRTHS2011</th>
      <th>BIRTHS2012</th>
      <th>BIRTHS2013</th>
      <th>BIRTHS2014</th>
      <th>BIRTHS2015</th>
      <th>POPESTIMATE2010</th>
      <th>POPESTIMATE2011</th>
      <th>POPESTIMATE2012</th>
      <th>POPESTIMATE2013</th>
      <th>POPESTIMATE2014</th>
      <th>POPESTIMATE2015</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Alabama</td>
      <td>Autauga County</td>
      <td>151</td>
      <td>636</td>
      <td>615</td>
      <td>574</td>
      <td>623</td>
      <td>600</td>
      <td>54660</td>
      <td>55253</td>
      <td>55175</td>
      <td>55038</td>
      <td>55290</td>
      <td>55347</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Alabama</td>
      <td>Baldwin County</td>
      <td>517</td>
      <td>2187</td>
      <td>2092</td>
      <td>2160</td>
      <td>2186</td>
      <td>2240</td>
      <td>183193</td>
      <td>186659</td>
      <td>190396</td>
      <td>195126</td>
      <td>199713</td>
      <td>203709</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Alabama</td>
      <td>Barbour County</td>
      <td>70</td>
      <td>335</td>
      <td>300</td>
      <td>283</td>
      <td>260</td>
      <td>269</td>
      <td>27341</td>
      <td>27226</td>
      <td>27159</td>
      <td>26973</td>
      <td>26815</td>
      <td>26489</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Alabama</td>
      <td>Bibb County</td>
      <td>44</td>
      <td>266</td>
      <td>245</td>
      <td>259</td>
      <td>247</td>
      <td>253</td>
      <td>22861</td>
      <td>22733</td>
      <td>22642</td>
      <td>22512</td>
      <td>22549</td>
      <td>22583</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Alabama</td>
      <td>Blount County</td>
      <td>183</td>
      <td>744</td>
      <td>710</td>
      <td>646</td>
      <td>618</td>
      <td>603</td>
      <td>57373</td>
      <td>57711</td>
      <td>57776</td>
      <td>57734</td>
      <td>57658</td>
      <td>57673</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>The US Census data breaks down population estimates by state and county. We can load the data and set the index to be a combination of the state and county values and see how pandas handles it in a DataFrame.</p>
<p>We do this by creating a list of the column identifiers we want to have indexed. And then calling set index with this list and assigning the output as appropriate. We see here that we have a dual index, first the state name and second the county name.</p>
<div class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index([<span class="st">'STNAME'</span>, <span class="st">'CTYNAME'</span>])</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>BIRTHS2010</th>
      <th>BIRTHS2011</th>
      <th>BIRTHS2012</th>
      <th>BIRTHS2013</th>
      <th>BIRTHS2014</th>
      <th>BIRTHS2015</th>
      <th>POPESTIMATE2010</th>
      <th>POPESTIMATE2011</th>
      <th>POPESTIMATE2012</th>
      <th>POPESTIMATE2013</th>
      <th>POPESTIMATE2014</th>
      <th>POPESTIMATE2015</th>
    </tr>
    <tr>
      <th>STNAME</th>
      <th>CTYNAME</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Alabama</th>
      <th>Autauga County</th>
      <td>151</td>
      <td>636</td>
      <td>615</td>
      <td>574</td>
      <td>623</td>
      <td>600</td>
      <td>54660</td>
      <td>55253</td>
      <td>55175</td>
      <td>55038</td>
      <td>55290</td>
      <td>55347</td>
    </tr>
    <tr>
      <th>Baldwin County</th>
      <td>517</td>
      <td>2187</td>
      <td>2092</td>
      <td>2160</td>
      <td>2186</td>
      <td>2240</td>
      <td>183193</td>
      <td>186659</td>
      <td>190396</td>
      <td>195126</td>
      <td>199713</td>
      <td>203709</td>
    </tr>
    <tr>
      <th>Barbour County</th>
      <td>70</td>
      <td>335</td>
      <td>300</td>
      <td>283</td>
      <td>260</td>
      <td>269</td>
      <td>27341</td>
      <td>27226</td>
      <td>27159</td>
      <td>26973</td>
      <td>26815</td>
      <td>26489</td>
    </tr>
    <tr>
      <th>Bibb County</th>
      <td>44</td>
      <td>266</td>
      <td>245</td>
      <td>259</td>
      <td>247</td>
      <td>253</td>
      <td>22861</td>
      <td>22733</td>
      <td>22642</td>
      <td>22512</td>
      <td>22549</td>
      <td>22583</td>
    </tr>
    <tr>
      <th>Blount County</th>
      <td>183</td>
      <td>744</td>
      <td>710</td>
      <td>646</td>
      <td>618</td>
      <td>603</td>
      <td>57373</td>
      <td>57711</td>
      <td>57776</td>
      <td>57734</td>
      <td>57658</td>
      <td>57673</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>An immediate question which comes up is how we can query this DataFrame. We saw previously that the loc attribute of the DataFrame can take multiple arguments. And it could query both the row and the columns.</p>
<p>When you use a MultiIndex, you must provide the arguments in order by the level you wish to query. Inside of the index, each column is called a level and the outermost column is level zero.</p>
<p>If we want to see the population results from Washtenaw County in Michigan the state, which is where I live, the first argument would be Michigan and the second would be Washtenaw County:</p>
<div class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>df.loc[<span class="st">'Michigan'</span>, <span class="st">'Washtenaw County'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="94">
<pre><code>BIRTHS2010            977
BIRTHS2011           3826
BIRTHS2012           3780
BIRTHS2013           3662
BIRTHS2014           3683
BIRTHS2015           3709
POPESTIMATE2010    345563
POPESTIMATE2011    349048
POPESTIMATE2012    351213
POPESTIMATE2013    354289
POPESTIMATE2014    357029
POPESTIMATE2015    358880
Name: (Michigan, Washtenaw County), dtype: int64</code></pre>
</div>
</div>
<p>If you are interested in comparing two counties, for example, Washtenaw and Wayne County, we can pass a list of tuples describing the indices we wish to query into loc. Since we have a MultiIndex of two values, the state and the county, we need to provide two values as each element of our filtering list. Each tuple should have two elements, the first element being the first index and the second element being the second index.</p>
<p>Therefore, in this case, we will have a list of two tuples, in each tuple, the first element is Michigan, and the second element is either Washtenaw County or Wayne County</p>
<div class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>df.loc[[(<span class="st">'Michigan'</span>, <span class="st">'Washtenaw County'</span>),</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'Michigan'</span>, <span class="st">'Wayne County'</span>)]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="95">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>BIRTHS2010</th>
      <th>BIRTHS2011</th>
      <th>BIRTHS2012</th>
      <th>BIRTHS2013</th>
      <th>BIRTHS2014</th>
      <th>BIRTHS2015</th>
      <th>POPESTIMATE2010</th>
      <th>POPESTIMATE2011</th>
      <th>POPESTIMATE2012</th>
      <th>POPESTIMATE2013</th>
      <th>POPESTIMATE2014</th>
      <th>POPESTIMATE2015</th>
    </tr>
    <tr>
      <th>STNAME</th>
      <th>CTYNAME</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Michigan</th>
      <th>Washtenaw County</th>
      <td>977</td>
      <td>3826</td>
      <td>3780</td>
      <td>3662</td>
      <td>3683</td>
      <td>3709</td>
      <td>345563</td>
      <td>349048</td>
      <td>351213</td>
      <td>354289</td>
      <td>357029</td>
      <td>358880</td>
    </tr>
    <tr>
      <th>Wayne County</th>
      <td>5918</td>
      <td>23819</td>
      <td>23270</td>
      <td>23377</td>
      <td>23607</td>
      <td>23586</td>
      <td>1815199</td>
      <td>1801273</td>
      <td>1792514</td>
      <td>1775713</td>
      <td>1766008</td>
      <td>1759335</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
<section id="missing-values" class="level2" data-number="5.13">
<h2 data-number="5.13" class="anchored" data-anchor-id="missing-values"><span class="header-section-number">5.13</span> Missing values</h2>
<p>We’ve seen a preview of how Pandas handles missing values using the None type and NumPy NaN values. Missing values are pretty common in data cleaning activities. And, missing values can be there for any number of reasons, and I just want to touch on a few here.</p>
<p>For instance, if you are running a survey and a respondant didn’t answer a question the missing value is actually an omission. This kind of missing data is called <strong>Missing at Random</strong> if there are other variables that might be used to predict the variable which is missing. In my work when I delivery surveys I often find that missing data, say the interest in being involved in a follow up study, often has some correlation with another data field, like gender or ethnicity. If there is no relationship to other variables, then we call this data <strong>Missing Completely at Random (MCAR)</strong>.</p>
<p>These are just two examples of missing data, and there are many more. For instance, data might be missing because it wasn’t collected, either by the process responsible for collecting that data, such as a researcher, or because it wouldn’t make sense if it were collected. This last example is extremely common when you start joining DataFrames together from multiple sources, such as joining a list of people at a university with a list of offices in the university (students generally don’t have offices).</p>
<p>Let’s look at some ways of handling missing data in pandas.</p>
<p>Pandas is pretty good at detecting missing values directly from underlying data formats, like CSV files. Although most missing valuse are often formatted as NaN, NULL, None, or N/A, sometimes missing values are not labeled so clearly.</p>
<p>For example, I’ve worked with social scientists who regularly used the value of 99 in binary categories to indicate a missing value. The pandas <code>read_csv()</code> function has a parameter called <strong>na_values</strong> to let us specify the form of missing values. It allows scalar, string, list, or dictionaries to be used.</p>
<div class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/class_grades.csv'</span>)</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="96">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Prefix</th>
      <th>Assignment</th>
      <th>Tutorial</th>
      <th>Midterm</th>
      <th>TakeHome</th>
      <th>Final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>57.14</td>
      <td>34.09</td>
      <td>64.38</td>
      <td>51.48</td>
      <td>52.50</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8</td>
      <td>95.05</td>
      <td>105.49</td>
      <td>67.50</td>
      <td>99.07</td>
      <td>68.33</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>83.70</td>
      <td>83.17</td>
      <td>NaN</td>
      <td>63.15</td>
      <td>48.89</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>49.38</td>
      <td>105.93</td>
      <td>80.56</td>
    </tr>
    <tr>
      <th>4</th>
      <td>8</td>
      <td>91.32</td>
      <td>93.64</td>
      <td>95.00</td>
      <td>107.41</td>
      <td>73.89</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>We can actually use the function <strong>.isnull()</strong> to create a boolean mask of the whole dataframe. This effectively broadcasts the isnull() function to every cell of data.</p>
<div class="cell" data-execution_count="97">
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> df.isnull()</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>mask.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="97">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Prefix</th>
      <th>Assignment</th>
      <th>Tutorial</th>
      <th>Midterm</th>
      <th>TakeHome</th>
      <th>Final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>3</th>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>This can be useful for processing rows based on certain columns of data. Another useful operation is to be able to drop all of those rows which have any missing data, which can be done with the <strong>dropna()</strong> function.</p>
<div class="cell" data-execution_count="98">
<div class="sourceCode cell-code" id="cb157"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>df.dropna().head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="98">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Prefix</th>
      <th>Assignment</th>
      <th>Tutorial</th>
      <th>Midterm</th>
      <th>TakeHome</th>
      <th>Final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>57.14</td>
      <td>34.09</td>
      <td>64.38</td>
      <td>51.48</td>
      <td>52.50</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8</td>
      <td>95.05</td>
      <td>105.49</td>
      <td>67.50</td>
      <td>99.07</td>
      <td>68.33</td>
    </tr>
    <tr>
      <th>4</th>
      <td>8</td>
      <td>91.32</td>
      <td>93.64</td>
      <td>95.00</td>
      <td>107.41</td>
      <td>73.89</td>
    </tr>
    <tr>
      <th>5</th>
      <td>7</td>
      <td>95.00</td>
      <td>92.58</td>
      <td>93.12</td>
      <td>97.78</td>
      <td>68.06</td>
    </tr>
    <tr>
      <th>6</th>
      <td>8</td>
      <td>95.05</td>
      <td>102.99</td>
      <td>56.25</td>
      <td>99.07</td>
      <td>50.00</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Note how the rows indexed with 2, 3, 7, and 11 are now gone.</p>
<p>One of the handy functions that Pandas has for working with missing values is the filling function, <strong>fillna()</strong>. This function takes a number or parameters. You could pass in a single value which is called a scalar value to change all of the missing data to one value. This isn’t really applicable in this case, but it’s a pretty common use case. So, if we wanted to fill all missing values with 0, we would use fillna.</p>
<div class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>df.fillna(<span class="dv">0</span>, inplace <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="99">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>Prefix</th>
      <th>Assignment</th>
      <th>Tutorial</th>
      <th>Midterm</th>
      <th>TakeHome</th>
      <th>Final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>57.14</td>
      <td>34.09</td>
      <td>64.38</td>
      <td>51.48</td>
      <td>52.50</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8</td>
      <td>95.05</td>
      <td>105.49</td>
      <td>67.50</td>
      <td>99.07</td>
      <td>68.33</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>83.70</td>
      <td>83.17</td>
      <td>0.00</td>
      <td>63.15</td>
      <td>48.89</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>49.38</td>
      <td>105.93</td>
      <td>80.56</td>
    </tr>
    <tr>
      <th>4</th>
      <td>8</td>
      <td>91.32</td>
      <td>93.64</td>
      <td>95.00</td>
      <td>107.41</td>
      <td>73.89</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Note that the inplace attribute causes pandas to fill the values inline and does not return a copy of the dataframe, but instead modifies the dataframe you have.</p>
<p>We can also use the <strong>na_filter</strong> option to turn off white space filtering, if white space is an actual value of interest. But in practice, this is pretty rare. In data without any NAs, passing na_filter=False, can improve the performance of reading a large file.</p>
<p>In addition to rules controlling how missing values might be loaded, it’s sometimes useful to consider missing values as actually having information. I’ll give an example from my own research. I often deal with logs from online learning systems. I’ve looked at video use in lecture capture systems. In these systems it’s common for the player for have a heartbeat functionality where playback statistics are sent to the server every so often, maybe every 30 seconds. These heartbeats can get big as they can carry the whole state of the playback system such as where the video play head is at, where the video size is, which video is being rendered to the screen, how loud the volume is.</p>
<p>If we load the data file log.csv, we can see an example of what this might look like.</p>
<div class="cell" data-execution_count="100">
<div class="sourceCode cell-code" id="cb159"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/log.csv'</span>)</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>df.head(n<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="100">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>time</th>
      <th>user</th>
      <th>video</th>
      <th>playback position</th>
      <th>paused</th>
      <th>volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1469974424</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>5</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1469974454</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>6</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1469974544</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>9</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1469974574</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>10</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1469977514</td>
      <td>bob</td>
      <td>intro.html</td>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1469977544</td>
      <td>bob</td>
      <td>intro.html</td>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1469977574</td>
      <td>bob</td>
      <td>intro.html</td>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>7</th>
      <td>1469977604</td>
      <td>bob</td>
      <td>intro.html</td>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>8</th>
      <td>1469974604</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>11</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>9</th>
      <td>1469974694</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>14</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>In this data the first column is a timestamp in the <strong>Unix epoch format</strong>. The next column is the user name followed by a web page they’re visiting and the video that they’re playing. Each row of the DataFrame has a playback position. And we can see that as the playback position increases by one, the time stamp increases by about 30 seconds.</p>
<p>Except for user Bob. It turns out that Bob has paused his playback so as time increases the playbackposition doesn’t change. Note too how difficult it is for us to try and derive this knowledge from the data, because it’s not sorted by time stamp as one might expect. This is actually not uncommon on systems which have a high degree of parallelism. There are a lot of missing values in the paused and volume columns. It’s not efficient to send this information across the network if it hasn’t changed. So this articular system just inserts null values into the database if there’s no changes.</p>
<p>Next up is the method <strong>parameter()</strong>. The two common fill values are ffill and bfill. <strong>ffill</strong> is for forward filling and it updates an na value for a particular cell with the value from the previous row.</p>
<p><strong>bfill</strong> is backward filling, which is the opposite of ffill. It fills the missing values with the next valid value.</p>
<p>It’s important to note that your data needs to be sorted in order for this to have the effect you might want. Data which comes from traditional database management systems usually has no order guarantee, justlike this data. So be careful.</p>
<p>In Pandas we can sort either by index or by values. Here we’ll just promote the time stamp to an index then sort on the index.</p>
<div class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index(<span class="st">'time'</span>)</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.sort_index()</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="101">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>user</th>
      <th>video</th>
      <th>playback position</th>
      <th>paused</th>
      <th>volume</th>
    </tr>
    <tr>
      <th>time</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1469974424</th>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>5</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>1469974424</th>
      <td>sue</td>
      <td>advanced.html</td>
      <td>23</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>1469974454</th>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>6</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1469974454</th>
      <td>sue</td>
      <td>advanced.html</td>
      <td>24</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1469974484</th>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>7</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>If we look closely at the output though we’ll notice that the index isn’t really unique.</p>
<p>Two users seem to be able to use the system at the same time. Again, a very common case. Let’s reset the index, and use some multi-level indexing on time AND user together instead,promote the user name to a second level of the index to deal with that issue.</p>
<div class="cell" data-execution_count="102">
<div class="sourceCode cell-code" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.reset_index()</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index([<span class="st">'time'</span>, <span class="st">'user'</span>])</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="102">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>video</th>
      <th>playback position</th>
      <th>paused</th>
      <th>volume</th>
    </tr>
    <tr>
      <th>time</th>
      <th>user</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">1469974424</th>
      <th>cheryl</th>
      <td>intro.html</td>
      <td>5</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>sue</th>
      <td>advanced.html</td>
      <td>23</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">1469974454</th>
      <th>cheryl</th>
      <td>intro.html</td>
      <td>6</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>sue</th>
      <td>advanced.html</td>
      <td>24</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1469974484</th>
      <th>cheryl</th>
      <td>intro.html</td>
      <td>7</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Now that we have the data indexed and sorted appropriately, we can fill the missing datas using ffill. It’s good to remember when dealing with missing values so you can deal with individual columns or sets of columns by projecting them. So you don’t have to fix all missing values in one command.</p>
<div class="cell" data-execution_count="103">
<div class="sourceCode cell-code" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.fillna(method <span class="op">=</span> <span class="st">'ffill'</span>)</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="103">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>video</th>
      <th>playback position</th>
      <th>paused</th>
      <th>volume</th>
    </tr>
    <tr>
      <th>time</th>
      <th>user</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">1469974424</th>
      <th>cheryl</th>
      <td>intro.html</td>
      <td>5</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>sue</th>
      <td>advanced.html</td>
      <td>23</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">1469974454</th>
      <th>cheryl</th>
      <td>intro.html</td>
      <td>6</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>sue</th>
      <td>advanced.html</td>
      <td>24</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>1469974484</th>
      <th>cheryl</th>
      <td>intro.html</td>
      <td>7</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>We can also do customized fill-in to replace values with the <strong>replace()</strong> function. It allows replacement from several approaches: value-to-value, list, dictionary, regex Let’s generate a simple example:</p>
<div class="cell" data-execution_count="104">
<div class="sourceCode cell-code" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'A'</span>: [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>],</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'B'</span>: [<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">9</span>],</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'C'</span>: [<span class="st">'a'</span>, <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>, <span class="st">'e'</span>]})</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="104">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>3</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>6</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>3</td>
      <td>c</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>8</td>
      <td>d</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>9</td>
      <td>e</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>We can replace 1’s with 100, let’s try the value-to-value approach:</p>
<div class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb164"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>df.replace(<span class="dv">1</span>,<span class="dv">100</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="105">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>100</td>
      <td>3</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>100</td>
      <td>6</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>3</td>
      <td>c</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>8</td>
      <td>d</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>9</td>
      <td>e</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>How about changing two values? Let’s try the list approach For example, we want to change 1’s to 100 and 3’s to 300:</p>
<div class="cell" data-execution_count="106">
<div class="sourceCode cell-code" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>df.replace([<span class="dv">1</span>,<span class="dv">3</span>], [<span class="dv">100</span>,<span class="dv">300</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="106">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>100</td>
      <td>300</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>100</td>
      <td>6</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>300</td>
      <td>c</td>
    </tr>
    <tr>
      <th>3</th>
      <td>300</td>
      <td>8</td>
      <td>d</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>9</td>
      <td>e</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>What’s really cool about pandas replacement is that it supports regex too! Let’s look at our data from the dataset logs again:</p>
<div class="cell" data-execution_count="107">
<div class="sourceCode cell-code" id="cb166"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/log.csv'</span>)</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="107">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>time</th>
      <th>user</th>
      <th>video</th>
      <th>playback position</th>
      <th>paused</th>
      <th>volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1469974424</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>5</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1469974454</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>6</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1469974544</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>9</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1469974574</td>
      <td>cheryl</td>
      <td>intro.html</td>
      <td>10</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1469977514</td>
      <td>bob</td>
      <td>intro.html</td>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>To replace using a regex we make the first parameter to replace the regex pattern we want to match, the second parameter the value we want to emit upon match, and then we pass in a third parameter “regex=True”.</p>
<p>Take a moment to pause this video and think about this problem: imagine we want to detect all html pages in the “video” column, lets say that just means they end with “.html”, and we want to overwrite that with the keyword “webpage”. How could we accomplish this?</p>
<div class="cell" data-execution_count="108">
<div class="sourceCode cell-code" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>df.replace(to_replace<span class="op">=</span><span class="st">'.*.html$'</span>, value<span class="op">=</span><span class="st">'webpage'</span>, regex <span class="op">=</span> <span class="va">True</span>).head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="108">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>time</th>
      <th>user</th>
      <th>video</th>
      <th>playback position</th>
      <th>paused</th>
      <th>volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1469974424</td>
      <td>cheryl</td>
      <td>webpage</td>
      <td>5</td>
      <td>False</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1469974454</td>
      <td>cheryl</td>
      <td>webpage</td>
      <td>6</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1469974544</td>
      <td>cheryl</td>
      <td>webpage</td>
      <td>9</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1469974574</td>
      <td>cheryl</td>
      <td>webpage</td>
      <td>10</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1469977514</td>
      <td>bob</td>
      <td>webpage</td>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
<section id="example-manipulating-a-dataframe" class="level2" data-number="5.14">
<h2 data-number="5.14" class="anchored" data-anchor-id="example-manipulating-a-dataframe"><span class="header-section-number">5.14</span> Example: Manipulating a dataframe</h2>
<p>In this lecture I’m going to walk through a basic data cleaning process with you and introduce you to a few more pandas API functions.</p>
<div class="cell" data-execution_count="109">
<div class="sourceCode cell-code" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'../data/week2/presidents.csv'</span>)</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="109">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>#</th>
      <th>President</th>
      <th>Born</th>
      <th>Age atstart of presidency</th>
      <th>Age atend of presidency</th>
      <th>Post-presidencytimespan</th>
      <th>Died</th>
      <th>Age</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>George Washington</td>
      <td>Feb 22, 1732[a]</td>
      <td>57&nbsp;years, 67&nbsp;daysApr 30, 1789</td>
      <td>65&nbsp;years, 10&nbsp;daysMar 4, 1797</td>
      <td>2&nbsp;years, 285&nbsp;days</td>
      <td>Dec 14, 1799</td>
      <td>67&nbsp;years, 295&nbsp;days</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>John Adams</td>
      <td>Oct 30, 1735[a]</td>
      <td>61&nbsp;years, 125&nbsp;daysMar 4, 1797</td>
      <td>65&nbsp;years, 125&nbsp;daysMar 4, 1801</td>
      <td>25&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>90&nbsp;years, 247&nbsp;days</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Thomas Jefferson</td>
      <td>Apr 13, 1743[a]</td>
      <td>57&nbsp;years, 325&nbsp;daysMar 4, 1801</td>
      <td>65&nbsp;years, 325&nbsp;daysMar 4, 1809</td>
      <td>17&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>83&nbsp;years, 82&nbsp;days</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>James Madison</td>
      <td>Mar 16, 1751[a]</td>
      <td>57&nbsp;years, 353&nbsp;daysMar 4, 1809</td>
      <td>65&nbsp;years, 353&nbsp;daysMar 4, 1817</td>
      <td>19&nbsp;years, 116&nbsp;days</td>
      <td>Jun 28, 1836</td>
      <td>85&nbsp;years, 104&nbsp;days</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>James Monroe</td>
      <td>Apr 28, 1758</td>
      <td>58&nbsp;years, 310&nbsp;daysMar 4, 1817</td>
      <td>66&nbsp;years, 310&nbsp;daysMar 4, 1825</td>
      <td>6&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1831</td>
      <td>73&nbsp;years, 67&nbsp;days</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Ok, we have some presidents, some dates, I see a bunch of footnotes in the “Born” column which might cause issues. Let’s start with cleaning up that name into firstname and lastname.</p>
<p>I’m going to tackle this with a regex. So I want to create two new columns and apply a regex to the projection of the “President” column.</p>
<p>Here’s one solution, we could make a copy of the President column:</p>
<div class="cell" data-execution_count="110">
<div class="sourceCode cell-code" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'First'</span>] <span class="op">=</span> df[<span class="st">'President'</span>]</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="co">#use replace to extract the first name</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'First'</span>] <span class="op">=</span> df[<span class="st">'First'</span>].replace(<span class="st">'[ ].*'</span>, <span class="st">''</span>, regex <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="110">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>#</th>
      <th>President</th>
      <th>Born</th>
      <th>Age atstart of presidency</th>
      <th>Age atend of presidency</th>
      <th>Post-presidencytimespan</th>
      <th>Died</th>
      <th>Age</th>
      <th>First</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>George Washington</td>
      <td>Feb 22, 1732[a]</td>
      <td>57&nbsp;years, 67&nbsp;daysApr 30, 1789</td>
      <td>65&nbsp;years, 10&nbsp;daysMar 4, 1797</td>
      <td>2&nbsp;years, 285&nbsp;days</td>
      <td>Dec 14, 1799</td>
      <td>67&nbsp;years, 295&nbsp;days</td>
      <td>George</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>John Adams</td>
      <td>Oct 30, 1735[a]</td>
      <td>61&nbsp;years, 125&nbsp;daysMar 4, 1797</td>
      <td>65&nbsp;years, 125&nbsp;daysMar 4, 1801</td>
      <td>25&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>90&nbsp;years, 247&nbsp;days</td>
      <td>John</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Thomas Jefferson</td>
      <td>Apr 13, 1743[a]</td>
      <td>57&nbsp;years, 325&nbsp;daysMar 4, 1801</td>
      <td>65&nbsp;years, 325&nbsp;daysMar 4, 1809</td>
      <td>17&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>83&nbsp;years, 82&nbsp;days</td>
      <td>Thomas</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>James Madison</td>
      <td>Mar 16, 1751[a]</td>
      <td>57&nbsp;years, 353&nbsp;daysMar 4, 1809</td>
      <td>65&nbsp;years, 353&nbsp;daysMar 4, 1817</td>
      <td>19&nbsp;years, 116&nbsp;days</td>
      <td>Jun 28, 1836</td>
      <td>85&nbsp;years, 104&nbsp;days</td>
      <td>James</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>James Monroe</td>
      <td>Apr 28, 1758</td>
      <td>58&nbsp;years, 310&nbsp;daysMar 4, 1817</td>
      <td>66&nbsp;years, 310&nbsp;daysMar 4, 1825</td>
      <td>6&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1831</td>
      <td>73&nbsp;years, 67&nbsp;days</td>
      <td>James</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>That works, but it’s kind of gross. And it’s slow, since we had to make a full copy of a column then go through and update strings. There are a few other ways we can deal with this. Let me show you the most general one first, and that’s called the <strong>apply()</strong> function. Let’s drop the column we made first:</p>
<div class="cell" data-execution_count="111">
<div class="sourceCode cell-code" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span>(df[<span class="st">'First'</span>])</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="111">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>#</th>
      <th>President</th>
      <th>Born</th>
      <th>Age atstart of presidency</th>
      <th>Age atend of presidency</th>
      <th>Post-presidencytimespan</th>
      <th>Died</th>
      <th>Age</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>George Washington</td>
      <td>Feb 22, 1732[a]</td>
      <td>57&nbsp;years, 67&nbsp;daysApr 30, 1789</td>
      <td>65&nbsp;years, 10&nbsp;daysMar 4, 1797</td>
      <td>2&nbsp;years, 285&nbsp;days</td>
      <td>Dec 14, 1799</td>
      <td>67&nbsp;years, 295&nbsp;days</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>John Adams</td>
      <td>Oct 30, 1735[a]</td>
      <td>61&nbsp;years, 125&nbsp;daysMar 4, 1797</td>
      <td>65&nbsp;years, 125&nbsp;daysMar 4, 1801</td>
      <td>25&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>90&nbsp;years, 247&nbsp;days</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Thomas Jefferson</td>
      <td>Apr 13, 1743[a]</td>
      <td>57&nbsp;years, 325&nbsp;daysMar 4, 1801</td>
      <td>65&nbsp;years, 325&nbsp;daysMar 4, 1809</td>
      <td>17&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>83&nbsp;years, 82&nbsp;days</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>James Madison</td>
      <td>Mar 16, 1751[a]</td>
      <td>57&nbsp;years, 353&nbsp;daysMar 4, 1809</td>
      <td>65&nbsp;years, 353&nbsp;daysMar 4, 1817</td>
      <td>19&nbsp;years, 116&nbsp;days</td>
      <td>Jun 28, 1836</td>
      <td>85&nbsp;years, 104&nbsp;days</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>James Monroe</td>
      <td>Apr 28, 1758</td>
      <td>58&nbsp;years, 310&nbsp;daysMar 4, 1817</td>
      <td>66&nbsp;years, 310&nbsp;daysMar 4, 1825</td>
      <td>6&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1831</td>
      <td>73&nbsp;years, 67&nbsp;days</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>The apply() function on a dataframe will take some arbitrary function you have written and apply it to either a Series (a single column) or DataFrame across all rows or columns. Lets write a function which just splits a string into two pieces using a single row of data:</p>
<div class="cell" data-execution_count="112">
<div class="sourceCode cell-code" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> splitname(row):</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The row is a single Series object which is a single row indexed by column values</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Let's extract the firstname and create a new entry in the series</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>    row[<span class="st">'First'</span>] <span class="op">=</span> row[<span class="st">'President'</span>].split(<span class="st">' '</span>)[<span class="dv">0</span>]</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>    row[<span class="st">'Last'</span>] <span class="op">=</span> row[<span class="st">'President'</span>].split(<span class="st">' '</span>)[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now we just return the row and the pandas .apply() will take of merging them back into a DataFrame</span></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row</span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Now if we apply this to the dataframe indicating we want to apply it across columns</span></span>
<span id="cb171-10"><a href="#cb171-10" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.<span class="bu">apply</span>(splitname, axis <span class="op">=</span> <span class="st">'columns'</span>)</span>
<span id="cb171-11"><a href="#cb171-11" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="112">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>#</th>
      <th>President</th>
      <th>Born</th>
      <th>Age atstart of presidency</th>
      <th>Age atend of presidency</th>
      <th>Post-presidencytimespan</th>
      <th>Died</th>
      <th>Age</th>
      <th>First</th>
      <th>Last</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>George Washington</td>
      <td>Feb 22, 1732[a]</td>
      <td>57&nbsp;years, 67&nbsp;daysApr 30, 1789</td>
      <td>65&nbsp;years, 10&nbsp;daysMar 4, 1797</td>
      <td>2&nbsp;years, 285&nbsp;days</td>
      <td>Dec 14, 1799</td>
      <td>67&nbsp;years, 295&nbsp;days</td>
      <td>George</td>
      <td>Washington</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>John Adams</td>
      <td>Oct 30, 1735[a]</td>
      <td>61&nbsp;years, 125&nbsp;daysMar 4, 1797</td>
      <td>65&nbsp;years, 125&nbsp;daysMar 4, 1801</td>
      <td>25&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>90&nbsp;years, 247&nbsp;days</td>
      <td>John</td>
      <td>Adams</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Thomas Jefferson</td>
      <td>Apr 13, 1743[a]</td>
      <td>57&nbsp;years, 325&nbsp;daysMar 4, 1801</td>
      <td>65&nbsp;years, 325&nbsp;daysMar 4, 1809</td>
      <td>17&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>83&nbsp;years, 82&nbsp;days</td>
      <td>Thomas</td>
      <td>Jefferson</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>James Madison</td>
      <td>Mar 16, 1751[a]</td>
      <td>57&nbsp;years, 353&nbsp;daysMar 4, 1809</td>
      <td>65&nbsp;years, 353&nbsp;daysMar 4, 1817</td>
      <td>19&nbsp;years, 116&nbsp;days</td>
      <td>Jun 28, 1836</td>
      <td>85&nbsp;years, 104&nbsp;days</td>
      <td>James</td>
      <td>Madison</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>James Monroe</td>
      <td>Apr 28, 1758</td>
      <td>58&nbsp;years, 310&nbsp;daysMar 4, 1817</td>
      <td>66&nbsp;years, 310&nbsp;daysMar 4, 1825</td>
      <td>6&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1831</td>
      <td>73&nbsp;years, 67&nbsp;days</td>
      <td>James</td>
      <td>Monroe</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Pretty questionable as to whether that is less gross, but it achieves the result and I find that I use the apply() function regularly in my work. The pandas series has a couple of other nice convenience functions though, and the next I would like to touch on is called <strong>.extract()</strong>. Lets drop our firstname and lastname.</p>
<div class="cell" data-execution_count="113">
<div class="sourceCode cell-code" id="cb172"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span>(df[<span class="st">'First'</span>])</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span>(df[<span class="st">'Last'</span>])</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="113">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>#</th>
      <th>President</th>
      <th>Born</th>
      <th>Age atstart of presidency</th>
      <th>Age atend of presidency</th>
      <th>Post-presidencytimespan</th>
      <th>Died</th>
      <th>Age</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>George Washington</td>
      <td>Feb 22, 1732[a]</td>
      <td>57&nbsp;years, 67&nbsp;daysApr 30, 1789</td>
      <td>65&nbsp;years, 10&nbsp;daysMar 4, 1797</td>
      <td>2&nbsp;years, 285&nbsp;days</td>
      <td>Dec 14, 1799</td>
      <td>67&nbsp;years, 295&nbsp;days</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>John Adams</td>
      <td>Oct 30, 1735[a]</td>
      <td>61&nbsp;years, 125&nbsp;daysMar 4, 1797</td>
      <td>65&nbsp;years, 125&nbsp;daysMar 4, 1801</td>
      <td>25&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>90&nbsp;years, 247&nbsp;days</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Thomas Jefferson</td>
      <td>Apr 13, 1743[a]</td>
      <td>57&nbsp;years, 325&nbsp;daysMar 4, 1801</td>
      <td>65&nbsp;years, 325&nbsp;daysMar 4, 1809</td>
      <td>17&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>83&nbsp;years, 82&nbsp;days</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>James Madison</td>
      <td>Mar 16, 1751[a]</td>
      <td>57&nbsp;years, 353&nbsp;daysMar 4, 1809</td>
      <td>65&nbsp;years, 353&nbsp;daysMar 4, 1817</td>
      <td>19&nbsp;years, 116&nbsp;days</td>
      <td>Jun 28, 1836</td>
      <td>85&nbsp;years, 104&nbsp;days</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>James Monroe</td>
      <td>Apr 28, 1758</td>
      <td>58&nbsp;years, 310&nbsp;daysMar 4, 1817</td>
      <td>66&nbsp;years, 310&nbsp;daysMar 4, 1825</td>
      <td>6&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1831</td>
      <td>73&nbsp;years, 67&nbsp;days</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Extract takes a regular expression as input and specifically requires you to set capture groups that correspond to the output columns you are interested in. Let’s write a regular expression that returned groups and just had the firstname and lastname in it, what would that look like?</p>
<p>Here we match three groups but only return two, the first and the last name. Remember, parenthesis mark groups we want to have returned and <code>?:</code> marks a group we do not want to be returned</p>
<div class="cell" data-execution_count="114">
<div class="sourceCode cell-code" id="cb173"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">'(^[\w]*)(?:.* )([\w]*$)'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now the extract function is built into the str attribute of the Series object, so we can call it using <strong>Series.str.extract(pattern)</strong>:</p>
<div class="cell" data-execution_count="115">
<div class="sourceCode cell-code" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'President'</span>].<span class="bu">str</span>.extract(pattern).head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="115">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>George</td>
      <td>Washington</td>
    </tr>
    <tr>
      <th>1</th>
      <td>John</td>
      <td>Adams</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Thomas</td>
      <td>Jefferson</td>
    </tr>
    <tr>
      <th>3</th>
      <td>James</td>
      <td>Madison</td>
    </tr>
    <tr>
      <th>4</th>
      <td>James</td>
      <td>Monroe</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>So that looks pretty nice, other than the column names. But if we name the groups we get named columns out:</p>
<div class="cell" data-execution_count="116">
<div class="sourceCode cell-code" id="cb175"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">'(?P&lt;First&gt;^[\w]*)(?:.* )(?P&lt;Last&gt;[\w]*$)'</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>names <span class="op">=</span> df[<span class="st">'President'</span>].<span class="bu">str</span>.extract(pattern)</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>names.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="116">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>First</th>
      <th>Last</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>George</td>
      <td>Washington</td>
    </tr>
    <tr>
      <th>1</th>
      <td>John</td>
      <td>Adams</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Thomas</td>
      <td>Jefferson</td>
    </tr>
    <tr>
      <th>3</th>
      <td>James</td>
      <td>Madison</td>
    </tr>
    <tr>
      <th>4</th>
      <td>James</td>
      <td>Monroe</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>And we can just copy these into our main dataframe if we want to:</p>
<div class="cell" data-execution_count="117">
<div class="sourceCode cell-code" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"First"</span>]<span class="op">=</span>names[<span class="st">"First"</span>]</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"Last"</span>]<span class="op">=</span>names[<span class="st">"Last"</span>]</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="117">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>#</th>
      <th>President</th>
      <th>Born</th>
      <th>Age atstart of presidency</th>
      <th>Age atend of presidency</th>
      <th>Post-presidencytimespan</th>
      <th>Died</th>
      <th>Age</th>
      <th>First</th>
      <th>Last</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>George Washington</td>
      <td>Feb 22, 1732[a]</td>
      <td>57&nbsp;years, 67&nbsp;daysApr 30, 1789</td>
      <td>65&nbsp;years, 10&nbsp;daysMar 4, 1797</td>
      <td>2&nbsp;years, 285&nbsp;days</td>
      <td>Dec 14, 1799</td>
      <td>67&nbsp;years, 295&nbsp;days</td>
      <td>George</td>
      <td>Washington</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>John Adams</td>
      <td>Oct 30, 1735[a]</td>
      <td>61&nbsp;years, 125&nbsp;daysMar 4, 1797</td>
      <td>65&nbsp;years, 125&nbsp;daysMar 4, 1801</td>
      <td>25&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>90&nbsp;years, 247&nbsp;days</td>
      <td>John</td>
      <td>Adams</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Thomas Jefferson</td>
      <td>Apr 13, 1743[a]</td>
      <td>57&nbsp;years, 325&nbsp;daysMar 4, 1801</td>
      <td>65&nbsp;years, 325&nbsp;daysMar 4, 1809</td>
      <td>17&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1826</td>
      <td>83&nbsp;years, 82&nbsp;days</td>
      <td>Thomas</td>
      <td>Jefferson</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>James Madison</td>
      <td>Mar 16, 1751[a]</td>
      <td>57&nbsp;years, 353&nbsp;daysMar 4, 1809</td>
      <td>65&nbsp;years, 353&nbsp;daysMar 4, 1817</td>
      <td>19&nbsp;years, 116&nbsp;days</td>
      <td>Jun 28, 1836</td>
      <td>85&nbsp;years, 104&nbsp;days</td>
      <td>James</td>
      <td>Madison</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>James Monroe</td>
      <td>Apr 28, 1758</td>
      <td>58&nbsp;years, 310&nbsp;daysMar 4, 1817</td>
      <td>66&nbsp;years, 310&nbsp;daysMar 4, 1825</td>
      <td>6&nbsp;years, 122&nbsp;days</td>
      <td>Jul 4, 1831</td>
      <td>73&nbsp;years, 67&nbsp;days</td>
      <td>James</td>
      <td>Monroe</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>It’s worth looking at the pandas str module for other functions which have been written specifically to clean up strings in DataFrames, and you can find that in the docs in the Working with Text section: https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html</p>
<p>Now lets move on to clean up that Born column. First, let’s get rid of anything that isn’t in the pattern of Month Day and Year:</p>
<div class="cell" data-execution_count="118">
<div class="sourceCode cell-code" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Born'</span>] <span class="op">=</span> df[<span class="st">'Born'</span>].<span class="bu">str</span>.extract(<span class="st">'([\w]</span><span class="sc">{3}</span><span class="st"> [\w]{1,2}, [\w]</span><span class="sc">{4}</span><span class="st">)'</span>)</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Born'</span>].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="118">
<pre><code>0    Feb 22, 1732
1    Oct 30, 1735
2    Apr 13, 1743
3    Mar 16, 1751
4    Apr 28, 1758
Name: Born, dtype: object</code></pre>
</div>
</div>
<p>So, that cleans up the date format. But I’m going to foreshadow something else here - the type of this column is object, and we know that’s what pandas uses when it is dealing with string. But pandas actually has really interesting date/time features - in fact, that’s one of the reasons Wes McKinney put his efforts into the library, to deal with financial transactions. So if I were building this out, I would actually update this column to the write data type as well:</p>
<div class="cell" data-execution_count="119">
<div class="sourceCode cell-code" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Born'</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">'Born'</span>])</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Born'</span>].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="119">
<pre><code>0   1732-02-22
1   1735-10-30
2   1743-04-13
3   1751-03-16
4   1758-04-28
Name: Born, dtype: datetime64[ns]</code></pre>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../code/3_regular_expressions.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Regex</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../code/5_pandas2.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data processing with pandas</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>