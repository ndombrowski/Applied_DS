{
  "hash": "6a5012ed4ce8a6a7e5c8e68adeab1c69",
  "result": {
    "markdown": "# Pivot tables\n\nA pivot table is a way of summarizing data in a DataFrame for a particular purpose. It makes heavy use of the aggregation function. \n\nA pivot table is itself a DataFrame, where the rows represent one variable that you're interested in, the columns another, and the cell's some aggregate value. A pivot table also tends to includes marginal values as well, which are the sums for each column and row. This allows you to be able to see the relationship between two variables at just a glance.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n```\n:::\n\n\nHere we have the Times Higher Education World University Ranking dataset, which is one of the most influential university measures. Let's import the dataset and see what it looks like:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndf = pd.read_csv('../data/week3/cwurData.csv')\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=tex}\n\\begin{tabular}{lrllrrrrrrrrrrr}\n\\toprule\n{} &  world\\_rank &                            institution &         country &  national\\_rank &  quality\\_of\\_education &  alumni\\_employment &  quality\\_of\\_faculty &  publications &  influence &  citations &  broad\\_impact &  patents &   score &  year \\\\\n\\midrule\n0 &           1 &                     Harvard University &             USA &              1 &                     7 &                  9 &                   1 &             1 &          1 &          1 &           NaN &        5 &  100.00 &  2012 \\\\\n1 &           2 &  Massachusetts Institute of Technology &             USA &              2 &                     9 &                 17 &                   3 &            12 &          4 &          4 &           NaN &        1 &   91.67 &  2012 \\\\\n2 &           3 &                    Stanford University &             USA &              3 &                    17 &                 11 &                   5 &             4 &          2 &          2 &           NaN &       15 &   89.50 &  2012 \\\\\n3 &           4 &                University of Cambridge &  United Kingdom &              1 &                    10 &                 24 &                   4 &            16 &         16 &         11 &           NaN &       50 &   86.17 &  2012 \\\\\n4 &           5 &     California Institute of Technology &             USA &              4 &                     2 &                 29 &                   7 &            37 &         22 &         22 &           NaN &       18 &   85.21 &  2012 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nHere we can see each institution's rank, country, quality of education, other metrics, and overall score.\n\nLet's say we want to create a new column called Rank_Level, where institutions with world ranking 1-100 are categorized as first tier and those with world ranking 101 - 200 are second tier, ranking 201 - 300 are third tier, after 301 is other top universities.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n#define ranking fct\ndef create_category(ranking):\n    if (ranking >= 1) & (ranking <=100):\n        return \"First tier\"\n    elif (ranking >= 101) & (ranking <=200):\n        return \"Second tier\"\n    elif (ranking >= 201) & (ranking <=300):\n        return('Third tier')\n    return \"Other Uni\"\n\n#apply function\ndf['Rank_Level'] = df['world_rank'].apply(lambda x: create_category(x))\n\n#view data\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=tex}\n\\begin{tabular}{lrllrrrrrrrrrrrl}\n\\toprule\n{} &  world\\_rank &                            institution &         country &  national\\_rank &  quality\\_of\\_education &  alumni\\_employment &  quality\\_of\\_faculty &  publications &  influence &  citations &  broad\\_impact &  patents &   score &  year &  Rank\\_Level \\\\\n\\midrule\n0 &           1 &                     Harvard University &             USA &              1 &                     7 &                  9 &                   1 &             1 &          1 &          1 &           NaN &        5 &  100.00 &  2012 &  First tier \\\\\n1 &           2 &  Massachusetts Institute of Technology &             USA &              2 &                     9 &                 17 &                   3 &            12 &          4 &          4 &           NaN &        1 &   91.67 &  2012 &  First tier \\\\\n2 &           3 &                    Stanford University &             USA &              3 &                    17 &                 11 &                   5 &             4 &          2 &          2 &           NaN &       15 &   89.50 &  2012 &  First tier \\\\\n3 &           4 &                University of Cambridge &  United Kingdom &              1 &                    10 &                 24 &                   4 &            16 &         16 &         11 &           NaN &       50 &   86.17 &  2012 &  First tier \\\\\n4 &           5 &     California Institute of Technology &             USA &              4 &                     2 &                 29 &                   7 &            37 &         22 &         22 &           NaN &       18 &   85.21 &  2012 &  First tier \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nA pivot table allows us to pivot out one of these columns a new column headers and compare it against another column as row indices. Let's say we want to compare rank level versus country of the universities and we want to compare in terms of overall score\n\nTo do this, we tell Pandas we want the values to be Score, and index to be the country and the columns to be the rank levels. Then we specify that the aggregation function, and here we'll use the NumPy mean to get the average rating for universities in that country:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndf.pivot_table(values='score', index='country', columns='Rank_Level', aggfunc = [np.mean]).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} & \\multicolumn{4}{l}{mean} \\\\\nRank\\_Level & First tier &  Other Uni & Second tier & Third tier \\\\\ncountry   &            &            &             &            \\\\\n\\midrule\nArgentina &        NaN &  44.672857 &         NaN &        NaN \\\\\nAustralia &    47.9425 &  44.645750 &     49.2425 &  47.285000 \\\\\nAustria   &        NaN &  44.864286 &         NaN &  47.066667 \\\\\nBelgium   &    51.8750 &  45.081000 &     49.0840 &  46.746667 \\\\\nBrazil    &        NaN &  44.499706 &     49.5650 &        NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe can see a  hierarchical dataframe where the index, or rows, are by country and the columns have two levels, the top level indicating that the mean value is being used and the second level being our ranks. In this example we only have one variable, the mean, that we are looking at, so we don't really need a hierarchical index.\n\nWe notice that there are some NaN values, for example, the first row, Argentia. The NaN values indicate that Argentia has only observations in the \"Other Top Universities\" category.\n\nNow, pivot tables aren't limited to one function that you might want to apply. You can pass a named parameter, aggfunc, which is a list of the different functions to apply, and pandas will provide you with the result using hierarchical column names.  Let's try that same query, but pass in the max() function too:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndf.pivot_table(values='score', index='country', columns='Rank_Level', aggfunc = [np.mean, np.max]).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=tex}\n\\begin{tabular}{lrrrrrrrr}\n\\toprule\n{} & \\multicolumn{4}{l}{mean} & \\multicolumn{4}{l}{amax} \\\\\nRank\\_Level & First tier &  Other Uni & Second tier & Third tier & First tier & Other Uni & Second tier & Third tier \\\\\ncountry   &            &            &             &            &            &           &             &            \\\\\n\\midrule\nArgentina &        NaN &  44.672857 &         NaN &        NaN &        NaN &     45.66 &         NaN &        NaN \\\\\nAustralia &    47.9425 &  44.645750 &     49.2425 &  47.285000 &      51.61 &     45.97 &       50.40 &      47.47 \\\\\nAustria   &        NaN &  44.864286 &         NaN &  47.066667 &        NaN &     46.29 &         NaN &      47.78 \\\\\nBelgium   &    51.8750 &  45.081000 &     49.0840 &  46.746667 &      52.03 &     46.21 &       49.73 &      47.14 \\\\\nBrazil    &        NaN &  44.499706 &     49.5650 &        NaN &        NaN &     46.08 &       49.82 &        NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nSo now we see we have both the mean and the max. \n\nAs mentioned earlier, we can also summarize the values within a given top level column. For instance, if we want to see an overall average for the country for the mean and we want to see the max of the max, we can indicate that we want pandas to provide marginal values:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndf.pivot_table(values='score', index='country', columns='Rank_Level', aggfunc=[np.mean, np.max], margins=True).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=tex}\n\\begin{tabular}{lrrrrrrrrrr}\n\\toprule\n{} & \\multicolumn{5}{l}{mean} & \\multicolumn{5}{l}{amax} \\\\\nRank\\_Level & First tier &  Other Uni & Second tier & Third tier &        All & First tier & Other Uni & Second tier & Third tier &    All \\\\\ncountry   &            &            &             &            &            &            &           &             &            &        \\\\\n\\midrule\nArgentina &        NaN &  44.672857 &         NaN &        NaN &  44.672857 &        NaN &     45.66 &         NaN &        NaN &  45.66 \\\\\nAustralia &    47.9425 &  44.645750 &     49.2425 &  47.285000 &  45.825517 &      51.61 &     45.97 &       50.40 &      47.47 &  51.61 \\\\\nAustria   &        NaN &  44.864286 &         NaN &  47.066667 &  45.139583 &        NaN &     46.29 &         NaN &      47.78 &  47.78 \\\\\nBelgium   &    51.8750 &  45.081000 &     49.0840 &  46.746667 &  47.011000 &      52.03 &     46.21 &       49.73 &      47.14 &  52.03 \\\\\nBrazil    &        NaN &  44.499706 &     49.5650 &        NaN &  44.781111 &        NaN &     46.08 &       49.82 &        NaN &  49.82 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nA pivot table is just a multi-level dataframe, and we can access series or cells in the dataframe in a similar way as we do so for a regular dataframe. \n\nLet's create a new dataframe from our previous example:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnew_df=df.pivot_table(values='score', index='country', columns='Rank_Level', aggfunc=[np.mean, np.max], margins=True)\n\n# Now let's look at the index\nprint(new_df.index)\n\n# And let's look at the columns\nprint(new_df.columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['Argentina', 'Australia', 'Austria', 'Belgium', 'Brazil', 'Bulgaria',\n       'Canada', 'Chile', 'China', 'Colombia', 'Croatia', 'Cyprus',\n       'Czech Republic', 'Denmark', 'Egypt', 'Estonia', 'Finland', 'France',\n       'Germany', 'Greece', 'Hong Kong', 'Hungary', 'Iceland', 'India', 'Iran',\n       'Ireland', 'Israel', 'Italy', 'Japan', 'Lebanon', 'Lithuania',\n       'Malaysia', 'Mexico', 'Netherlands', 'New Zealand', 'Norway', 'Poland',\n       'Portugal', 'Puerto Rico', 'Romania', 'Russia', 'Saudi Arabia',\n       'Serbia', 'Singapore', 'Slovak Republic', 'Slovenia', 'South Africa',\n       'South Korea', 'Spain', 'Sweden', 'Switzerland', 'Taiwan', 'Thailand',\n       'Turkey', 'USA', 'Uganda', 'United Arab Emirates', 'United Kingdom',\n       'Uruguay', 'All'],\n      dtype='object', name='country')\nMultiIndex([('mean',  'First tier'),\n            ('mean',   'Other Uni'),\n            ('mean', 'Second tier'),\n            ('mean',  'Third tier'),\n            ('mean',         'All'),\n            ('amax',  'First tier'),\n            ('amax',   'Other Uni'),\n            ('amax', 'Second tier'),\n            ('amax',  'Third tier'),\n            ('amax',         'All')],\n           names=[None, 'Rank_Level'])\n```\n:::\n:::\n\n\nWe can see the columns are hierarchical. The top level column indices have two categories: mean and max, and the lower level column indices have four categories, which are the four rank levels. \n\nHow would we query this if we want to get the average scores of First Tier Top Unversity levels in each country? We would just need to make two dataframe projections, the first for the mean, then the second for the top tier:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nnew_df['mean']['First tier'].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  First tier \\\\\ncountry   &             \\\\\n\\midrule\nArgentina &         NaN \\\\\nAustralia &     47.9425 \\\\\nAustria   &         NaN \\\\\nBelgium   &     51.8750 \\\\\nBrazil    &         NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe can see that the output is a series object which we can confirm by printing the type. Remember that when you project a single column of values out of a DataFrame you get a series.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ntype(new_df['mean']['First tier'])\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\npandas.core.series.Series\n```\n:::\n:::\n\n\nWhat if we want to find the country that has the maximum average score on First Tier Top University level? We can use the **idxmax()** function.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nnew_df['mean']['First tier'].idxmax()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n'United Kingdom'\n```\n:::\n:::\n\n\nNow, the idxmax() function isn't special for pivot tables, it's a built in function to the Series object.\n\nWe don't have time to go over all pandas functions and attributes, and I want to encourage you to explore the API to learn more deeply what is available to you.\n\nIf you want to achieve a different shape of your pivot table, you can do so with the stack and unstack functions. \n\n- **Stacking** is pivoting the lowermost column index to become the innermost row index. - **Unstacking** is the inverse of stacking, pivoting the innermost row index to become the lowermost column index. An example will help make this clear\n\nLet's look at our pivot table first to refresh what it looks like:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nnew_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=tex}\n\\begin{tabular}{lrrrrrrrrrr}\n\\toprule\n{} & \\multicolumn{5}{l}{mean} & \\multicolumn{5}{l}{amax} \\\\\nRank\\_Level & First tier &  Other Uni & Second tier & Third tier &        All & First tier & Other Uni & Second tier & Third tier &    All \\\\\ncountry   &            &            &             &            &            &            &           &             &            &        \\\\\n\\midrule\nArgentina &        NaN &  44.672857 &         NaN &        NaN &  44.672857 &        NaN &     45.66 &         NaN &        NaN &  45.66 \\\\\nAustralia &    47.9425 &  44.645750 &     49.2425 &  47.285000 &  45.825517 &      51.61 &     45.97 &       50.40 &      47.47 &  51.61 \\\\\nAustria   &        NaN &  44.864286 &         NaN &  47.066667 &  45.139583 &        NaN &     46.29 &         NaN &      47.78 &  47.78 \\\\\nBelgium   &    51.8750 &  45.081000 &     49.0840 &  46.746667 &  47.011000 &      52.03 &     46.21 &       49.73 &      47.14 &  52.03 \\\\\nBrazil    &        NaN &  44.499706 &     49.5650 &        NaN &  44.781111 &        NaN &     46.08 &       49.82 &        NaN &  49.82 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nNow let's try stacking, this should move the lowermost column, so the tiers of the university rankings, to the inner most row:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nnew_df = new_df.stack()\nnew_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=tex}\n\\begin{tabular}{llrr}\n\\toprule\n          &             &       mean &   amax \\\\\ncountry & Rank\\_Level &            &        \\\\\n\\midrule\nArgentina & Other Uni &  44.672857 &  45.66 \\\\\n          & All &  44.672857 &  45.66 \\\\\nAustralia & First tier &  47.942500 &  51.61 \\\\\n          & Other Uni &  44.645750 &  45.97 \\\\\n          & Second tier &  49.242500 &  50.40 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nIn the original pivot table, rank levels are the lowermost column, after stacking, rank levels become the innermost index, appearing to the right after country.\n\nNow let's try unstacking:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nnew_df.unstack().head()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=tex}\n\\begin{tabular}{lrrrrrrrrrr}\n\\toprule\n{} & \\multicolumn{5}{l}{mean} & \\multicolumn{5}{l}{amax} \\\\\nRank\\_Level & First tier &  Other Uni & Second tier & Third tier &        All & First tier & Other Uni & Second tier & Third tier &     All \\\\\ncountry   &            &            &             &            &            &            &           &             &            &         \\\\\n\\midrule\nAll       &  58.350675 &  44.738871 &    49.06545 &  46.843450 &  47.798395 &     100.00 &     46.34 &       51.29 &      47.93 &  100.00 \\\\\nArgentina &        NaN &  44.672857 &         NaN &        NaN &  44.672857 &        NaN &     45.66 &         NaN &        NaN &   45.66 \\\\\nAustralia &  47.942500 &  44.645750 &    49.24250 &  47.285000 &  45.825517 &      51.61 &     45.97 &       50.40 &      47.47 &   51.61 \\\\\nAustria   &        NaN &  44.864286 &         NaN &  47.066667 &  45.139583 &        NaN &     46.29 &         NaN &      47.78 &   47.78 \\\\\nBelgium   &  51.875000 &  45.081000 &    49.08400 &  46.746667 &  47.011000 &      52.03 &     46.21 &       49.73 &      47.14 &   52.03 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nThat seems to restore our dataframe to its original shape. What do you think would happen if we unstacked twice in a row?\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nnew_df.unstack().unstack().head()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=tex}\n\\begin{tabular}{lllr}\n\\toprule\n     &            &         &          0 \\\\\n{} & Rank\\_Level & country &            \\\\\n\\midrule\nmean & First tier & All &  58.350675 \\\\\n     &            & Argentina &        NaN \\\\\n     &            & Australia &  47.942500 \\\\\n     &            & Austria &        NaN \\\\\n     &            & Belgium &  51.875000 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe actually end up unstacking all the way to just a single column, so a series object is returned. This column is just a \"value\", the meaning of which is denoted by the hierarchical index of operation, rank, and country.\n\n",
    "supporting": [
      "9_pivot_files/figure-pdf"
    ],
    "filters": []
  }
}