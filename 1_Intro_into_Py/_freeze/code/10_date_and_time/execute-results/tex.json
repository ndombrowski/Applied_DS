{
  "hash": "5b57f1485741e65df2759fd4b92cbafe",
  "result": {
    "markdown": "# Dates and times\n\nNow we'll be looking at the time series and date functionally in pandas. Manipulating dates and time is quite flexible in Pandas and thus allows us to conduct more analysis such as time series analysis, which we will talk about soon. Actually, pandas was originally created by Wed McKinney to handle date and time data when he worked as a consultant for hedge funds.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport pytz\n```\n:::\n\n\n## Timestamp\n\nPandas has four main time related classes. Timestamp, DatetimeIndex, Period, and PeriodIndex. First, let's look at Timestamp. It represents a single timestamp and associates values with points in time.\n\nFor example, let's create a timestamp using a string 9/1/2019 10:05AM, and here we have our timestamp. Timestamp is interchangeable with Python's datetime in most cases.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npd.Timestamp('10/1/2019 10:05AM')\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTimestamp('2019-10-01 10:05:00')\n```\n:::\n:::\n\n\nWe can also create a timestamp by passing multiple parameters such as year, month, date, hour, minute, separately:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\npd.Timestamp(2019,12,20,0,0)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nTimestamp('2019-12-20 00:00:00')\n```\n:::\n:::\n\n\nTimestamp also has some useful attributes, such as isoweekday(), which shows the weekday of the timestamp note that 1 represents Monday and 7 represents Sunday:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\npd.Timestamp(2019,12,30,0,0).isoweekday()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n1\n```\n:::\n:::\n\n\nYou can find extract the specific year, month, day, hour, minute, second from a timestamp:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\npd.Timestamp(2019,12,20,5,2,23).second\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n23\n```\n:::\n:::\n\n\n## Period\n\nSuppose we weren't interested in a specific point in time and instead wanted a span of time. This is where the Period class comes into play. Period represents a single time span, such as a specific day or month.\n\nHere we are creating a period that is January 2016:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\npd.Period('1/2016')\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nPeriod('2016-01', 'M')\n```\n:::\n:::\n\n\nYou'll notice when we print that out that the granularity of the period is M for month, since that was the finest grained piece we provided. Here's an example of a period that is March 5th, 2016.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\npd.Period('3/5/2016')\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nPeriod('2016-03-05', 'D')\n```\n:::\n:::\n\n\nPeriod objects represent the full timespan that you specify. Arithmetic on period is very easy and intuitive, for instance, if we want to find out 5 months after January 2016, we simply plus 5:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\npd.Period('1/2016') + 5\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nPeriod('2016-06', 'M')\n```\n:::\n:::\n\n\nFrom the result, you can see we get June 2016. If we want to find out two days before March 5th 2016, we simply subtract 2:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\npd.Period('3/5/2016') - 2\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nPeriod('2016-03-03', 'D')\n```\n:::\n:::\n\n\nThe key here is that the period object encapsulates the granularity for arithmetic.\n\n\n## DatetimeIndex and PeriodIndex\n\nThe index of a timestamp is DatetimeIndex. Let's look at a quick example. First, let's create our example series t1, we'll use the Timestamp of September 1st, 2nd and 3rd of 2016. When we look at the series, each Timestamp is the index and has a value associated with it, in this case, a, b and c.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nt1 = pd.Series(list('abc'), [pd.Timestamp('2016-09-01'), pd.Timestamp('2016-09-02'), \n                             pd.Timestamp('2016-09-03')])\nt1\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &  0 \\\\\n\\midrule\n2016-09-01 &  a \\\\\n2016-09-02 &  b \\\\\n2016-09-03 &  c \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nLooking at the type of our series index, we see that it's DatetimeIndex.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ntype(t1.index)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\npandas.core.indexes.datetimes.DatetimeIndex\n```\n:::\n:::\n\n\nSimilarly, we can create a period-based index as well. \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nt2 = pd.Series(list('def'), [pd.Period('2016-09'), pd.Period('2016-10'), \n                             pd.Period('2016-11')])\nt2\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &  0 \\\\\n\\midrule\n2016-09 &  d \\\\\n2016-10 &  e \\\\\n2016-11 &  f \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nLooking at the type of the ts2.index, we can see that it's PeriodIndex. \n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ntype(t2.index)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\npandas.core.indexes.period.PeriodIndex\n```\n:::\n:::\n\n\n## Converting to datetime\n\nNow, let's look into how to convert to Datetime. Suppose we have a list of dates as strings and we want to create a new dataframe.\n\nI'm going to try a bunch of different date formats:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nd1 = ['2 June 2013', 'Aug 29, 2014', '2015-06-26', '7/12/16']\n\n# And just some random data\nts3 = pd.DataFrame(np.random.randint(10, 100, (4,2)), index=d1, \n                   columns=list('ab'))\nts3\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &   a &   b \\\\\n\\midrule\n2 June 2013  &  78 &  49 \\\\\nAug 29, 2014 &  27 &  71 \\\\\n2015-06-26   &  68 &  74 \\\\\n7/12/16      &  87 &  51 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nUsing pandas to_datetime, pandas will try to convert these to Datetime and put them in a standard format.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nts3.index = pd.to_datetime(ts3.index, dayfirst = True)\nts3\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &   a &   b \\\\\n\\midrule\n2013-06-02 &  78 &  49 \\\\\n2014-08-29 &  27 &  71 \\\\\n2015-06-26 &  68 &  74 \\\\\n2016-12-07 &  87 &  51 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nto_datetime also() has options to change the date parse order. For example, we  can pass in the argument dayfirst = True to parse the date in European date.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\npd.to_datetime('4.7.12', dayfirst=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nTimestamp('2012-07-04 00:00:00')\n```\n:::\n:::\n\n\n## Timedelta\n\nTimedeltas are differences in times. This is not the same as a a period, but conceptually similar. For instance, if we want to take the difference between September 3rd and  September 1st, we get a Timedelta of two days.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\npd.Timestamp('9/3/2016') - pd.Timestamp('9/1/2016')\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nTimedelta('2 days 00:00:00')\n```\n:::\n:::\n\n\nWe can also do something like find what the date and time is for 12 days and three hours past September 2nd, at 8:10 AM.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\npd.Timestamp('9/2/2016 8:10AM') + pd.Timedelta('12D 3H')\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nTimestamp('2016-09-14 11:10:00')\n```\n:::\n:::\n\n\n## Offset\n\nOffset is similar to timedelta, but it follows specific calendar duration rules. Offset allows flexibility in terms of types of time intervals. Besides hour, day, week, month, etc it also has business day, end of month, semi month begin etc.\n\nLet's create a timestamp, and see what day is that:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\npd.Timestamp('9/4/2016').weekday()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n6\n```\n:::\n:::\n\n\nNow we can now add the timestamp with a week ahead:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\npd.Timestamp('09/04/2016') + pd.offsets.Week()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nTimestamp('2016-09-11 00:00:00')\n```\n:::\n:::\n\n\nNow let's try to do the month end, then we would have the last day of September:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\npd.Timestamp('9/4/2016') + pd.offsets.MonthEnd()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nTimestamp('2016-09-30 00:00:00')\n```\n:::\n:::\n\n\n## Working with dates in a dataframe\n\nNext, let's look at a few tricks for working with dates in a DataFrame. Suppose we want to look at nine measurements, taken bi-weekly, every Sunday, starting in October 2016. \n\nUsing date_range, we can create this DatetimeIndex. In data_range, we have to either specify the start or end date. If it is not explicitly specified, by default, the date is considered the start date. Then we have to specify number of periods, and a frequency. Here, we set it to \"2W-SUN\", which means biweekly on Sunday:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndates = pd.date_range('10-01-2016', periods=9, freq='2W-SUN')\ndates\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nDatetimeIndex(['2016-10-02', '2016-10-16', '2016-10-30', '2016-11-13',\n               '2016-11-27', '2016-12-11', '2016-12-25', '2017-01-08',\n               '2017-01-22'],\n              dtype='datetime64[ns]', freq='2W-SUN')\n```\n:::\n:::\n\n\nThere are many other frequencies that you can specify. For example, you can do business day:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\npd.date_range('10-01-2016', periods=9, freq='B')\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\nDatetimeIndex(['2016-10-03', '2016-10-04', '2016-10-05', '2016-10-06',\n               '2016-10-07', '2016-10-10', '2016-10-11', '2016-10-12',\n               '2016-10-13'],\n              dtype='datetime64[ns]', freq='B')\n```\n:::\n:::\n\n\nOr you can do quarterly, with the quarter start in June:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\npd.date_range('04-01-2016', periods=12, freq='QS-JUN')\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\nDatetimeIndex(['2016-06-01', '2016-09-01', '2016-12-01', '2017-03-01',\n               '2017-06-01', '2017-09-01', '2017-12-01', '2018-03-01',\n               '2018-06-01', '2018-09-01', '2018-12-01', '2019-03-01'],\n              dtype='datetime64[ns]', freq='QS-JUN')\n```\n:::\n:::\n\n\nNow, let's go back to our weekly on Sunday example and create a DataFrame using these dates, and some random data, and see what we can do with it.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ndates = pd.date_range('10-01-2016', periods=9, freq='2W-SUN')\ndf = pd.DataFrame({'Count 1': 100 + np.random.randint(-5, 10, 9).cumsum(),\n                  'Count 2': 120 + np.random.randint(-5, 10, 9)}, index=dates)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &  Count 1 &  Count 2 \\\\\n\\midrule\n2016-10-02 &      104 &      123 \\\\\n2016-10-16 &      113 &      117 \\\\\n2016-10-30 &      109 &      115 \\\\\n2016-11-13 &      109 &      124 \\\\\n2016-11-27 &      113 &      115 \\\\\n2016-12-11 &      114 &      125 \\\\\n2016-12-25 &      109 &      117 \\\\\n2017-01-08 &      115 &      128 \\\\\n2017-01-22 &      122 &      128 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nFirst, we can check what day of the week a specific date is. For example, here we can see that all the dates in our index are on a Sunday. Which matches the frequency that we set:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\ndf.index.weekday\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\nInt64Index([6, 6, 6, 6, 6, 6, 6, 6, 6], dtype='int64')\n```\n:::\n:::\n\n\nWe can also use diff() to find the difference between each date's value.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndf.diff()\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &  Count 1 &  Count 2 \\\\\n\\midrule\n2016-10-02 &      NaN &      NaN \\\\\n2016-10-16 &      9.0 &     -6.0 \\\\\n2016-10-30 &     -4.0 &     -2.0 \\\\\n2016-11-13 &      0.0 &      9.0 \\\\\n2016-11-27 &      4.0 &     -9.0 \\\\\n2016-12-11 &      1.0 &     10.0 \\\\\n2016-12-25 &     -5.0 &     -8.0 \\\\\n2017-01-08 &      6.0 &     11.0 \\\\\n2017-01-22 &      7.0 &      0.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nSuppose we want to know what the mean count is for each month in our DataFrame. We can do this using **resample.** Converting from a higher frequency from a lower frequency is called downsampling (we'll talk about this in a moment):\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ndf.resample('M').mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &     Count 1 &     Count 2 \\\\\n\\midrule\n2016-10-31 &  108.666667 &  118.333333 \\\\\n2016-11-30 &  111.000000 &  119.500000 \\\\\n2016-12-31 &  111.500000 &  121.000000 \\\\\n2017-01-31 &  118.500000 &  128.000000 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nNow let's talk about datetime indexing and slicing, which is a wonderful feature of the pandas DataFrame. For instance, we can use partial string indexing to find values from a particular year:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ndf['2017']\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &  Count 1 &  Count 2 \\\\\n\\midrule\n2017-01-08 &      115 &      128 \\\\\n2017-01-22 &      122 &      128 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nOr we can do it from a particular month:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndf.loc['2016-12']\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &  Count 1 &  Count 2 \\\\\n\\midrule\n2016-12-11 &      114 &      125 \\\\\n2016-12-25 &      109 &      117 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nOr we can even slice on a range of dates For example, here we only want the values from December 2016 onwards.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndf['2016-12':]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &  Count 1 &  Count 2 \\\\\n\\midrule\n2016-12-11 &      114 &      125 \\\\\n2016-12-25 &      109 &      117 \\\\\n2017-01-08 &      115 &      128 \\\\\n2017-01-22 &      122 &      128 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n",
    "supporting": [
      "10_date_and_time_files/figure-pdf"
    ],
    "filters": []
  }
}