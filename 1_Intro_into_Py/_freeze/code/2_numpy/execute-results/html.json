{
  "hash": "b2c43e2888645b5693e70b873969cccf",
  "result": {
    "markdown": "# Numpy\n\nNumpy is the fundamental package for numeric computing with Python. It provides powerful ways to create, store, and/or manipulate data, which makes it able to seamlessly and speedily integrate with a wide variety of databases. This is also the foundation that Pandas is built on, which is a high-performance data-centric package that we will learn later in the course.\n\nIn this lecture, we will talk about creating array with certain data types, manipulating array, selecting elements from arrays, and loading dataset into array. Such functions are useful for manipulating data and understanding the functionalities of other common Python data packages.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport math\n```\n:::\n\n\n## Array creation\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Arrays are displayed as a list or list of lists and can be created through list as well. When creating an\n# array, we pass in a list as an argument in numpy array\na = np.array([1, 2, 3])\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# We can print the number of dimensions of a list using the ndim attribute\nprint(a.ndim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# If we pass in a list of lists in numpy array, we create a multi-dimensional array, for instance, a matrix\nb = np.array([[1,2,3],[4,5,6]])\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([[1, 2, 3],\n       [4, 5, 6]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# We can print out the length of each dimension by calling the shape attribute, which returns a tuple\nb.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n(2, 3)\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# We can also check the type of items in the array\na.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\ndtype('int64')\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Besides integers, floats are also accepted in numpy arrays\nc = np.array([2.2, 5, 1.1])\nc.dtype.name\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n'float64'\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Let's look at the data in our array\nc\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([2.2, 5. , 1.1])\n```\n:::\n:::\n\n\nNote that numpy automatically converts integers, like 5, up to floats, since there is no loss of precision. Numpy will try and give you the best data type format possible to keep your data types homogeneous, which means all the same, in the array.\n\nSometimes we know the shape of an array that we want to create, but not what we want to be in it. numpy offers several functions to create arrays with initial placeholders, such as zero's or one's.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Lets create two arrays, both the same shape but with different filler values\nd = np.zeros((2,3))\nprint(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0. 0. 0.]\n [0. 0. 0.]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ne = np.ones((2,3))\nprint(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 1. 1.]\n [1. 1. 1.]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# We can also generate an array with random numbers\nnp.random.rand(2,3)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([[0.54749485, 0.67006722, 0.39011362],\n       [0.78564183, 0.71416696, 0.73579126]])\n```\n:::\n:::\n\n\nYou'll see zeros, ones, and rand used quite often to create example arrays, especially in stack overflow posts and other forums.\n\nWe can also create a sequence of numbers in an array with the `arrange()` function: \n\n- The fist argument is the starting bound \n- the second argument is the ending bound\n- the third argument is the difference between each consecutive numbers\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Let's create an array of every even number from ten (inclusive) to fifty (exclusive)\nf = np.arange(10, 50, 2)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,\n       44, 46, 48])\n```\n:::\n:::\n\n\nIf we want to generate a sequence of floats, we can use the `linspace()` function. In this function the third argument isn't the difference between two numbers, but the total number of items you want to generate\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n#create 15 numbers from 0 (inclusive) to 2 (inclusive)\nnp.linspace( 0, 2, 15 ) \n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([0.        , 0.14285714, 0.28571429, 0.42857143, 0.57142857,\n       0.71428571, 0.85714286, 1.        , 1.14285714, 1.28571429,\n       1.42857143, 1.57142857, 1.71428571, 1.85714286, 2.        ])\n```\n:::\n:::\n\n\n## Array operations\n\nWe can do many things on arrays, such as mathematical manipulation (addition, subtraction, square, exponents) as well as use boolean arrays, which are binary values. We can also do matrix manipulation such as product, transpose, inverse, and so forth.\n\nArithmetic operators on array apply elementwise.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Let's create a couple of arrays\na = np.array([10,20,30,40])\nb = np.array([1, 2, 3,4])\n\n# Now let's look at a minus b\nc = a-b\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 9 18 27 36]\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# And let's look at a times b\nd = a*b\nprint(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 10  40  90 160]\n```\n:::\n:::\n\n\nWith **arithmetic manipulation**, we can convert current data to the way we want it to be. Here's a real-world problem I face - I moved down to the United States about 6 years ago from Canada. In Canada we use celcius for temperatures, and my wife still hasn't converted to the US system which uses farenheit. With numpy I could easily convert a number of farenheit values, say the weather forecase, to ceclius:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Let's create an array of typical Ann Arbor winter farenheit values\nfarenheit = np.array([0,-10,-5,-15,0])\n\ncelcius = (farenheit - 31) * (5/9)\ncelcius\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray([-17.22222222, -22.77777778, -20.        , -25.55555556,\n       -17.22222222])\n```\n:::\n:::\n\n\nAnother useful and important manipulation is the **boolean array**. We can apply an operator on an array, and a boolean array will be returned for any element in the original, with True being emitted if it meets the condition and False otherwise. For instance, if we want to get a boolean array to check celcius degrees that are greater than -20 degrees\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ncelcius > -20\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([ True, False, False, False,  True])\n```\n:::\n:::\n\n\nHere's another example, we could use the **modulus operator** to check numbers in an array to see if they are even. Recall that modulus does division but throws away everything but the remainder (decimal) portion)\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ncelcius%2 == 0\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([False, False,  True, False, False])\n```\n:::\n:::\n\n\nBesides element-wise manipulation, it is important to know that numpy supports matrix manipulation. Let's look at matrix product. if we want to do elementwise product, we use the \"*\" sign\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nA = np.array([[1,1],[0,1]])\nB = np.array([[2,0],[3,4]])\nprint(A*B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[2 0]\n [0 4]]\n```\n:::\n:::\n\n\nIf we want to do **matrix product**, we use the \"@\" sign or use the dot function\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nprint(A@B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[5 4]\n [3 4]]\n```\n:::\n:::\n\n\nA few more linear algebra concepts are worth layering in here. You might recall that the product of two matrices is only plausible when the inner dimensions of the two matrices are the same. The dimensions refer to the number of elements both horizontally and vertically in the rendered matrices you've seen here. We can use numpy to quickly see the shape of a matrix:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nA.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n(2, 2)\n```\n:::\n:::\n\n\nWhen manipulating arrays of different types, the type of the resulting array will correspond to the more general of the two types. This is called **upcasting**.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Let's create an array of integers\narray1 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(array1.dtype)\n\n# Now let's create an array of floats\narray2 = np.array([[7.1, 8.2, 9.1], [10.4, 11.2, 12.3]])\nprint(array2.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nint64\nfloat64\n```\n:::\n:::\n\n\n**Integers (int)** are whole numbers only, and **Floating** point numbers (float) can have a whole number portion and a decimal portion. The **64** in this example refers to the number of bits that the operating system is reserving to represent the number, which determines the size (or precision) of the numbers that can be represented.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Let's do an addition for the two arrays\narray3=array1+array2\nprint(array3)\nprint(array3.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 8.1 10.2 12.1]\n [14.4 16.2 18.3]]\nfloat64\n```\n:::\n:::\n\n\nNotice how the items in the resulting array have been upcast into floating point numbers.\n\nNumpy arrays have many interesting aggregation functions on them, such as  sum(), max(), min(), and mean().\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nprint(array3.sum())\nprint(array3.max())\nprint(array3.min())\nprint(array3.mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n79.3\n18.3\n8.1\n13.216666666666667\n```\n:::\n:::\n\n\nFor two dimensional arrays, we can do the same thing for each row or column, let's create an array with 15 elements, ranging from 1 to 15, with a dimension of 3X5.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nb = np.arange(1,16,1).reshape(3,5)\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1  2  3  4  5]\n [ 6  7  8  9 10]\n [11 12 13 14 15]]\n```\n:::\n:::\n\n\nNow, we often think about two dimensional arrays being made up of rows and columns, but you can also think of these arrays as just a giant ordered list of numbers, and the *shape* of the array, the number of rows and columns, is just an abstraction that we have for a particular purpose. Actually, this is exactly how basic images are stored in computer environments.\n\nLet's take a look at an example and see how numpy comes into play.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# For this demonstration I'll use the python imaging library (PIL) and a function to display images in the\n# Jupyter notebook\nfrom PIL import Image\nfrom IPython.display import display\n\n# And let's just look at the image I'm talking about\nim = Image.open('../images/chris.tiff')\ndisplay(im)\n```\n\n::: {.cell-output .cell-output-display}\n![](2_numpy_files/figure-html/cell-27-output-1.png){}\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Now, we can convert this PIL image to a numpy array\narray=np.array(im)\nprint(array.shape)\nprint(array[:1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(200, 200)\n[[118 117 118 118 112 103  92  82  66  56  45  39  38  40  43  46  53  53\n   53  52  48  43  39  36  19  15  15  16  24  28  33  35  39  34  28  23\n   15   8   8  16  41  60  91 118 135 141 141 141 133 120 103  87  73  68\n   77  91 105 109 117 121 120 114 104  98  84  76  70  72  76  82  94 107\n  113 121 126 132 133 135 137 139 144 145 150 157 166 171 170 168 169 157\n  145 138 130 124 125 134 137 141 145 148 148 143 138 136 134 133 133 133\n  138 142 147 150 146 140 126 108  85  61  44  34  39  49  65  83 104 125\n  143 155 150 155 153 146 135 120  99  80  69  63  65  78  98 116 134 147\n  155 165 170 166 159 154 146 137 125 119 117 122 127 129 131 135 138 142\n  146 150 152 150 148 145 144 141 139 138 139 137 133 129 124 126 128 129\n  129 127 125 123 120 120 124 126 125 122 117 114 115 114 113 108 105 103\n  107 110]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\narray.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\ndtype('uint8')\n```\n:::\n:::\n\n\nHere we see that we have a 200x200 array and that the values are all uint8. The **uint** means that they are unsigned integers (so no negative numbers) and the 8 means 8 bits per byte. This means that each value can be up to 2*2*2*2*2*2*2*2=256 in size (well, actually 255, because we start at zero).\n\nFor black and white images black is stored as 0 and white is stored as 255. So if we just wanted to invert this image we could use the numpy array to do so\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Let's create an array the same shape\nmask=np.full(array.shape,255)\nmask\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\narray([[255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255],\n       ...,\n       [255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255],\n       [255, 255, 255, ..., 255, 255, 255]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Now let's subtract that from the modified array\nmodified_array=array-mask\n\n# And lets convert all of the negative values to positive values\nmodified_array=modified_array*-1\n\n# And as a last step, let's tell numpy to set the value of the datatype correctly\nmodified_array=modified_array.astype(np.uint8)\nmodified_array\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\narray([[137, 138, 137, ..., 152, 148, 145],\n       [142, 142, 142, ..., 155, 152, 149],\n       [147, 147, 148, ..., 160, 157, 153],\n       ...,\n       [ 78,  74,  73, ...,  62,  57,  63],\n       [ 77,  73,  72, ...,  62,  54,  66],\n       [ 77,  73,  71, ...,  62,  54,  68]], dtype=uint8)\n```\n:::\n:::\n\n\nAnd lastly, lets display this new array. We do this by using the `fromarray()` function in the python imaging library to convert the numpy array into an object jupyter can render\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndisplay(Image.fromarray(modified_array))\n```\n\n::: {.cell-output .cell-output-display}\n![](2_numpy_files/figure-html/cell-32-output-1.png){}\n:::\n:::\n\n\nOk, remember how I started this by talking about how we could just think of this as a giant array of bytes, and that the shape was an abstraction? Well, we could just decide to reshape the array and still try and render it. PIL is interpreting the individual rows as lines, so we can change the number of lines and columns if we want to. What do you think that would look like?\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nreshaped=np.reshape(modified_array,(100,400))\nprint(reshaped.shape)\ndisplay(Image.fromarray(reshaped))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(100, 400)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](2_numpy_files/figure-html/cell-33-output-2.png){}\n:::\n:::\n\n\nBy reshaping the array to be only 100 rows high but 400 columns we've essentially doubled the image by taking every other line and stacking them out in width. This makes the image look more stretched out too.\n\nThis isn't an image manipulation course, but the point was to show you that these numpy arrays are really just abstractions on top of data, and that data has an underlying format (in this case, uint8). But further, we can build abstractions on top of that, such as computer code which renders a byte as either black or white, which has meaning to people.\n\n\n\n## Indexing, Slicing, Iterating\n\nIndexing, slicing and iterating are extremely important for data manipulation and analysis because these techniques allow us to select data based on conditions, and copy or update data.\n\n### Indexing\n\nFirst we are going to look at integer **indexing**. A one-dimensional array, works in similar ways as a list. To get an element in a one-dimensional array, we simply use the offset index.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\na = np.array([1,3,5,7])\na[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n5\n```\n:::\n:::\n\n\nFor multidimensional array, we need to use integer array indexing, let's create a new multidimensional array:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\na = np.array([[1,2], [3, 4], [5, 6]])\na\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n```\n:::\n:::\n\n\nIf we want to select one certain element, we can do so by entering the index, which is comprised of two  integers the first being the row, and the second the column.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\na[1,1]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n4\n```\n:::\n:::\n\n\nIf we want to get multiple elements for example, 1, 4, and 6 and put them into a one-dimensional array we can enter the indices directly into an array function:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nnp.array([a[0, 0], a[1, 1], a[2, 1]])\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\narray([1, 4, 6])\n```\n:::\n:::\n\n\nWe can also do that by using another form of **array indexing**, which essentially \"zips\" the first list and the second list up:\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nprint(a[[0, 1, 2], [0, 1, 1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 4 6]\n```\n:::\n:::\n\n\n### Boolean indexing\n\nBoolean indexing allows us to select arbitrary elements based on conditions. For example, in the matrix we just talked about we want to find elements that are greater than 5 so we set up a conditon a >5 :\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nprint(a >5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[False False]\n [False False]\n [False  True]]\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\nThis returns a boolean array showing that if the value at the corresponding index is greater than 5.\n\nWe can then place this array of booleans like a mask over the original array to return a one-dimensional array relating to the true values.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nprint(a[a>5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[6]\n```\n:::\n:::\n\n\n### Slicing\n\nSlicing is a way to create a sub-array based on the original array. For one-dimensional arrays, slicing works in similar ways to a list. To slice, we use the : sign. For instance, if we put :3 in the indexing brackets, we get elements from index 0 to index 3 (excluding index 3)\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\na = np.array([0,1,2,3,4,5])\nprint(a[:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2]\n```\n:::\n:::\n\n\nBy putting 2:4 in the bracket, we get elements from index 2 to index 4 (excluding index 4)\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nprint(a[2:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 3]\n```\n:::\n:::\n\n\nFor multi-dimensional arrays, it works similarly, lets see an example\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\na = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\na\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n```\n:::\n:::\n\n\nFirst, if we put one argument in the array, for example a[:2] then we would get all the elements from the first (0th) and second row (1th)\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\na[:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n```\n:::\n:::\n\n\nIf we add another argument to the array, for example `a[:2, 1:3]`, we get the first two rows but then the second and third column values only\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\na[:2, 1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\narray([[2, 3],\n       [6, 7]])\n```\n:::\n:::\n\n\n**So, in multidimensional arrays, the first argument is for selecting rows, and the second argument is for selecting columns**\n\nIt is important to realize that a slice of an array is a view into the same data. This is called **passing by reference**. So modifying the sub array will consequently modify the original array\n\nHere I'll change the element at position [0, 0], which is 2, to 50, then we can see that the value in the original array is changed to 50 as well\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\na = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\nsub_array = a[:2, 1:3]\nsub_array\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\narray([[2, 3],\n       [6, 7]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nprint(\"sub array index [0,0] value before change:\", sub_array[0,0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsub array index [0,0] value before change: 2\n```\n:::\n:::\n\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nsub_array[0,0] = 50\nsub_array\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\narray([[50,  3],\n       [ 6,  7]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\nprint(\"sub array index [0,0] value after change:\", sub_array[0,0])\nprint(\"original array index [0,1] value after change:\", a[0,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsub array index [0,0] value after change: 50\noriginal array index [0,1] value after change: 50\n```\n:::\n:::\n\n\n## Trying numpy with datasets\n\nNow that we have learned the essentials of Numpy let's use it on a couple of datasets.\n\nHere we have a very popular dataset on wine quality, and we are going to only look at red wines. The data fields include: fixed acidity, volatile acidity, citric acid, residual sugar, chlorides, free sulfur dioxide,total sulfur dioxide density, pH, sulphates, alcohol, quality.\n\nTo load a dataset in Numpy, we can use the `genfromtxt()` function. We can specify data file name, delimiter (which is optional but often used), and number of rows to skip if we have a header row, hence it is 1 here\n\nThe genfromtxt() function has a parameter called dtype for specifying data types of each column this parameter is optional. Without specifying the types, all types will be casted the same to the more general/precise type.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\nwines = np.genfromtxt(\"../data/week1/winequality-red.csv\", delimiter=\";\", skip_header=1)\nwines\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\narray([[ 7.4  ,  0.7  ,  0.   , ...,  0.56 ,  9.4  ,  5.   ],\n       [ 7.8  ,  0.88 ,  0.   , ...,  0.68 ,  9.8  ,  5.   ],\n       [ 7.8  ,  0.76 ,  0.04 , ...,  0.65 ,  9.8  ,  5.   ],\n       ...,\n       [ 6.3  ,  0.51 ,  0.13 , ...,  0.75 , 11.   ,  6.   ],\n       [ 5.9  ,  0.645,  0.12 , ...,  0.71 , 10.2  ,  5.   ],\n       [ 6.   ,  0.31 ,  0.47 , ...,  0.66 , 11.   ,  6.   ]])\n```\n:::\n:::\n\n\nRecall that we can use integer indexing to get a certain column or a row. For example, if we want to select the fixed acidity column, which is the first coluumn, we can do so by entering the index into the array.\n\nAlso remember that for multidimensional arrays, the first argument refers to the row, and the second argument refers to the column, and if we just give one argument then we'll get a single dimensional list back.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# So all rows combined but only the first column from them would be\nprint(\"one integer 0 for slicing: \", wines[:, 0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\none integer 0 for slicing:  [7.4 7.8 7.8 ... 6.3 5.9 6. ]\n```\n:::\n:::\n\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# But if we wanted the same values but wanted to preserve that they sit in their own rows we would write\nprint(\"0 to 1 for slicing: \\n\", wines[:, 0:1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 to 1 for slicing: \n [[7.4]\n [7.8]\n [7.8]\n ...\n [6.3]\n [5.9]\n [6. ]]\n```\n:::\n:::\n\n\nThis is another great example of how the shape of the data is an abstraction which we can layer intentionally on top of the data we are working with.\n\nIf we want a range of columns in order, say columns 0 through 3 (recall, this means first, second, and third, since we start at zero and don't include the training index value), we can do that too:\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\nwines[:, 0:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\narray([[7.4  , 0.7  , 0.   ],\n       [7.8  , 0.88 , 0.   ],\n       [7.8  , 0.76 , 0.04 ],\n       ...,\n       [6.3  , 0.51 , 0.13 ],\n       [5.9  , 0.645, 0.12 ],\n       [6.   , 0.31 , 0.47 ]])\n```\n:::\n:::\n\n\nWhat if we want several non-consecutive columns? We can place the indices of the columns that we want into an array and pass the array as the second argument. Here's an example:\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\nwines[:, [0,2,4]]\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\narray([[7.4  , 0.   , 0.076],\n       [7.8  , 0.   , 0.098],\n       [7.8  , 0.04 , 0.092],\n       ...,\n       [6.3  , 0.13 , 0.076],\n       [5.9  , 0.12 , 0.075],\n       [6.   , 0.47 , 0.067]])\n```\n:::\n:::\n\n\nWe can also do some basic summarization of this dataset. \n\nFor example, if we want to find out the average quality of red wine, we can select the quality column. We could do this in a couple of ways, but the most appropriate is to use the -1 value for the index, as negative numbers mean slicing from the back of the list. We can then call the aggregation functions on this data.\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\nwines[:,-1].mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n5.6360225140712945\n```\n:::\n:::\n\n\nLet's take a look at another dataset, this time on graduate school admissions. It has fields such as GRE score, TOEFL score, university rating, GPA, having research experience or not, and a chance of admission.\n\nWith this dataset, we can do data manipulation and basic analysis to infer what conditions are associated with higher chance of admission. Let's take a look.\n\nWe can specify data field names when using genfromtxt() to load CSV data. Also, we can have numpy try and infer the type of a column by setting the dtype parameter to None:\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\ngraduate_admission = np.genfromtxt('../data/week1/Admission_Predict.csv', dtype=None, delimiter=',', skip_header=1, names=('Serial No','GRE Score', 'TOEFL Score', 'University Rating', 'SOP','LOR','CGPA','Research', 'Chance of Admit'))\n\ngraduate_admission[:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\narray([(1, 337, 118, 4, 4.5, 4.5, 9.65, 1, 0.92),\n       (2, 324, 107, 4, 4. , 4.5, 8.87, 1, 0.76)],\n      dtype=[('Serial_No', '<i8'), ('GRE_Score', '<i8'), ('TOEFL_Score', '<i8'), ('University_Rating', '<i8'), ('SOP', '<f8'), ('LOR', '<f8'), ('CGPA', '<f8'), ('Research', '<i8'), ('Chance_of_Admit', '<f8')])\n```\n:::\n:::\n\n\nNotice that the resulting array is actually a one-dimensional array with 400 tuples: \n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\ngraduate_admission.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\n(400,)\n```\n:::\n:::\n\n\nWe can retrieve a column from the array using the column's name for example, let's get the CGPA column and only the first five values.\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\ngraduate_admission['CGPA'][0:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\narray([9.65, 8.87, 8.  , 8.67, 8.21])\n```\n:::\n:::\n\n\nSince the GPA in the dataset range from 1 to 10, and in the US it's more common to use a scale of up to 4, a common task might be to convert the GPA by dividing by 10 and then multiplying by 4\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\ngraduate_admission['CGPA'] = graduate_admission['CGPA'] /10 *4\ngraduate_admission['CGPA'][0:20] #let's get 20 values\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\narray([3.86 , 3.548, 3.2  , 3.468, 3.284, 3.736, 3.28 , 3.16 , 3.2  ,\n       3.44 , 3.36 , 3.6  , 3.64 , 3.2  , 3.28 , 3.32 , 3.48 , 3.2  ,\n       3.52 , 3.4  ])\n```\n:::\n:::\n\n\nRecall boolean masking. We can use this to find out how many students have had research experience by creating a boolean mask and passing it to the array indexing operator\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nlen(graduate_admission[graduate_admission['Research'] == 1])\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\n219\n```\n:::\n:::\n\n\nSince we have the data field chance of admission, which ranges from 0 to 1, we can try to see if students with high chance of admission (>0.8) on average have higher GRE score than those with lower chance of admission (<0.4)\n\nSo first we use boolean masking to pull out only those students we are interested in based on their chance of admission, then we pull out only their GPA scores, then we print the mean values.\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nprint(graduate_admission[graduate_admission['Chance_of_Admit'] > 0.8]['GRE_Score'].mean())\nprint(graduate_admission[graduate_admission['Chance_of_Admit'] < 0.4]['GRE_Score'].mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n328.7350427350427\n302.2857142857143\n```\n:::\n:::\n\n\nTake a moment to reflect here, do you understand what is happening in these calls?\n\nWhen we do the boolean masking we are left with an array with tuples in it still, and numpy holds underneath this a list of the columns we specified and their name and indexes\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\ngraduate_admission[graduate_admission['Chance_of_Admit'] > 0.8][:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\narray([(1, 337, 118, 4, 4.5, 4.5, 3.86 , 1, 0.92),\n       (6, 330, 115, 5, 4.5, 3. , 3.736, 1, 0.9 )],\n      dtype=[('Serial_No', '<i8'), ('GRE_Score', '<i8'), ('TOEFL_Score', '<i8'), ('University_Rating', '<i8'), ('SOP', '<f8'), ('LOR', '<f8'), ('CGPA', '<f8'), ('Research', '<i8'), ('Chance_of_Admit', '<f8')])\n```\n:::\n:::\n\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\n# Let's also do this with GPA\nprint(graduate_admission[graduate_admission['Chance_of_Admit'] > 0.8]['CGPA'].mean())\nprint(graduate_admission[graduate_admission['Chance_of_Admit'] < 0.4]['CGPA'].mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.7106666666666666\n3.0222857142857142\n```\n:::\n:::\n\n\nThe GPA and GRE for students who have a higher chance of being admitted, at least based on our cursory look here, seems to be higher.\n\n",
    "supporting": [
      "2_numpy_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}