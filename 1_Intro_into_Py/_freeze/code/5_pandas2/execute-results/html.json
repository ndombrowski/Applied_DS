{
  "hash": "dd94a08e0e53635eeff00de2ab67a520",
  "result": {
    "markdown": "# Data processing with pandas\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n```\n:::\n\n\n## Merging dataframes\n\nIn this lecture we're going to address how you can bring multiple dataframe objects together, either by merging them horizontally, or by concatenating them vertically.\n\n![Venn Diagram](../images/merging1.png)\n\nAbove we see a **Venn Diagram**. A Venn Diagram is traditionally used to show set membership. For example, the circle on the left is the population of students at a university. The circle on the right is the population of staff at a university. And the overlapping region in the middle are all of those students who are also staff. Maybe these students run tutorials for a course, or grade assignments, or engage in running research experiments.\n\nSo, this diagram shows two populations whom we might have data about, but there is overlap between those populations.\n\nWhen it comes to translating this to pandas, we can think of the case where we might have these two populations as indices in separate DataFrames, maybe with the label of Person Name. When we want to join the DataFrames together, we have some choices to make. First what if we want a list of all the people regardless of whether they're staff or student, and all of the information we can get on them? In database terminology, this is called a **full outer join**. And in set theory, it's called a **union**. In the Venn diagram, it represents everyone in any circle.\n\nHere's an image of what that would look like in the Venn diagram.\n\n\n![Union](../images/merging2.png)\nIt's quite possible though that we only want those people who we have maximum information for, those people who are both staff and students. Maybe being a staff member and a student involves getting a tuition waiver, and we want to calculate the cost of this. In database terminology, this is called an **inner join**. Or in set theory, the **intersection.** It is represented in the Venn diagram as the overlapping parts of each circle.\n\n![Intersection](../images/merging3.png)\nLet's have a look at an actual example:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# First we create two DataFrames, staff and students.\nstaff_df = pd.DataFrame([{'Name': 'Kelly', 'Role': 'Director of HR'},\n                         {'Name': 'Sally', 'Role': 'Course liasion'},\n                         {'Name': 'James', 'Role': 'Grader'}])\n\n# And lets index these staff by name\nstaff_df = staff_df.set_index('Name')\n\n# Now we'll create a student dataframe\nstudent_df = pd.DataFrame([{'Name': 'James', 'School': 'Business'},\n                           {'Name': 'Mike', 'School': 'Law'},\n                           {'Name': 'Sally', 'School': 'Engineering'}])\n\n# And we'll index this by name too\nstudent_df = student_df.set_index('Name')\n\n# And lets just print out the dataframes\nprint(staff_df.head())\nprint(student_df.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 Role\nName                 \nKelly  Director of HR\nSally  Course liasion\nJames          Grader\n            School\nName              \nJames     Business\nMike           Law\nSally  Engineering\n```\n:::\n:::\n\n\nThere's some overlap in these DataFrames in that James and Sally are both students and staff, but Mike and Kelly are not. Importantly, both DataFrames are indexed along the value we want to merge them on, which is called Name.\n\nIf we want the **union** of these, we would call merge() passing in the DataFrame on the left and the DataFrame on the right and telling merge that we want it to use an outer join. We want to use the left and right indices as the joining columns.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\npd.merge(staff_df, student_df, how = 'outer', left_index = True, right_index = True)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Role</th>\n      <th>School</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>James</th>\n      <td>Grader</td>\n      <td>Business</td>\n    </tr>\n    <tr>\n      <th>Kelly</th>\n      <td>Director of HR</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>Mike</th>\n      <td>NaN</td>\n      <td>Law</td>\n    </tr>\n    <tr>\n      <th>Sally</th>\n      <td>Course liasion</td>\n      <td>Engineering</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n We see in the resulting DataFrame that everyone is listed. And since Mike does not have a role, and John does not have a school, those cells are listed as missing values.\n\nIf we wanted to get the **intersection**, that is, just those who are a student AND a staff, we could set the how attribute to inner. Again, we set both left and right indices to be true as the joining columns:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\npd.merge(staff_df, student_df, how = 'inner', left_index = True, right_index = True)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Role</th>\n      <th>School</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Sally</th>\n      <td>Course liasion</td>\n      <td>Engineering</td>\n    </tr>\n    <tr>\n      <th>James</th>\n      <td>Grader</td>\n      <td>Business</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAnd we see the resulting DataFrame has only James and Sally in it. Now there are two other common use cases when merging DataFrames, and both are examples of what we would call set addition. \n\nThe first is when we would want to get a list of all staff regardless of whether they were students or not. But if they were students, we would want to get their student details as well. To do this we would use a **left join**. It is important to note the order of dataframes in this function: the first dataframe is the left dataframe and the second is the right:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\npd.merge(staff_df, student_df, how = 'left', left_index = True, right_index = True)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Role</th>\n      <th>School</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Kelly</th>\n      <td>Director of HR</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>Sally</th>\n      <td>Course liasion</td>\n      <td>Engineering</td>\n    </tr>\n    <tr>\n      <th>James</th>\n      <td>Grader</td>\n      <td>Business</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nYou could probably guess what comes next. We want a list of all of the students and their roles if they were also staff. To do this we would do a **right join**.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\npd.merge(staff_df, student_df, how = 'right', left_index = True, right_index = True)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Role</th>\n      <th>School</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>James</th>\n      <td>Grader</td>\n      <td>Business</td>\n    </tr>\n    <tr>\n      <th>Mike</th>\n      <td>NaN</td>\n      <td>Law</td>\n    </tr>\n    <tr>\n      <th>Sally</th>\n      <td>Course liasion</td>\n      <td>Engineering</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can also do it another way. The merge method has a couple of other interesting parameters. First, you don't need to use indices to join on, you can use columns as well. \n\nHere's an example. Here we have a parameter called \"on\", and we can assign a column that both dataframe has as the joining column\n\nFirst, lets remove our index from both of our dataframes:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nstaff_df = staff_df.reset_index()\nstudent_df = student_df.reset_index()\n\n#merge\npd.merge(staff_df, student_df, how = 'right', on = 'Name')\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Role</th>\n      <th>School</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>James</td>\n      <td>Grader</td>\n      <td>Business</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Mike</td>\n      <td>NaN</td>\n      <td>Law</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Sally</td>\n      <td>Course liasion</td>\n      <td>Engineering</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSo what happens when we have **conflicts between the DataFrames**? \n\nLet's take a look by creating new staff and student DataFrames that have a location information added to them.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nstaff_df = pd.DataFrame([{'Name': 'Kelly', 'Role': 'Director of HR', \n                          'Location': 'State Street'},\n                         {'Name': 'Sally', 'Role': 'Course liasion', \n                          'Location': 'Washington Avenue'},\n                         {'Name': 'James', 'Role': 'Grader', \n                          'Location': 'Washington Avenue'}])\n\nstudent_df = pd.DataFrame([{'Name': 'James', 'School': 'Business', \n                            'Location': '1024 Billiard Avenue'},\n                           {'Name': 'Mike', 'School': 'Law', \n                            'Location': 'Fraternity House #22'},\n                           {'Name': 'Sally', 'School': 'Engineering', \n                            'Location': '512 Wilson Crescent'}])\n                            \nprint(staff_df)\nprint(student_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Name            Role           Location\n0  Kelly  Director of HR       State Street\n1  Sally  Course liasion  Washington Avenue\n2  James          Grader  Washington Avenue\n    Name       School              Location\n0  James     Business  1024 Billiard Avenue\n1   Mike          Law  Fraternity House #22\n2  Sally  Engineering   512 Wilson Crescent\n```\n:::\n:::\n\n\nIn the staff DataFrame, this is an office location where we can find the staff person. And we can see the Director of HR is on State Street, while the two students are on Washington Avenue. But for the student DataFrame, the location information is actually their home address.\n\nThe merge function preserves this information, but appends an _x or _y to help differentiate between which index went with which column of data. The _x is always the left DataFrame information, and the _y is always the right DataFrame information.\n\nHere, if we want all the staff information regardless of whether they were students or not. But if they were students, we would want to get their student details as well.Then we can do a left join and on the column of Name:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\npd.merge(staff_df, student_df, how = 'left', on = 'Name')\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Role</th>\n      <th>Location_x</th>\n      <th>School</th>\n      <th>Location_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Kelly</td>\n      <td>Director of HR</td>\n      <td>State Street</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Sally</td>\n      <td>Course liasion</td>\n      <td>Washington Avenue</td>\n      <td>Engineering</td>\n      <td>512 Wilson Crescent</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>James</td>\n      <td>Grader</td>\n      <td>Washington Avenue</td>\n      <td>Business</td>\n      <td>1024 Billiard Avenue</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFrom the output, we can see there are columns Location_x and Location_y. Location_x refers to the Location column in the left dataframe, which is staff dataframe and Location_y refers to the Location column in the right dataframe, which is student dataframe.\n\nBefore we leave merging of DataFrames, let's talk about **multi-indexing and multiple columns**. It's quite possible that the first name for students and staff might overlap, but the last name might not. In this case, we use a list of the multiple columns that should be used to join keys from both dataframes on the on parameter. Recall that the column name(s) assigned to the on parameter needs to exist in both dataframes.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nstaff_df = pd.DataFrame([{'First Name': 'Kelly', 'Last Name': 'Desjardins', \n                          'Role': 'Director of HR'},\n                         {'First Name': 'Sally', 'Last Name': 'Brooks', \n                          'Role': 'Course liasion'},\n                         {'First Name': 'James', 'Last Name': 'Wilde', \n                          'Role': 'Grader'}])\n\nstudent_df = pd.DataFrame([{'First Name': 'James', 'Last Name': 'Hammond', \n                            'School': 'Business'},\n                           {'First Name': 'Mike', 'Last Name': 'Smith', \n                            'School': 'Law'},\n                           {'First Name': 'Sally', 'Last Name': 'Brooks', \n                            'School': 'Engineering'}])\n\nprint(staff_df)\nprint(student_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  First Name   Last Name            Role\n0      Kelly  Desjardins  Director of HR\n1      Sally      Brooks  Course liasion\n2      James       Wilde          Grader\n  First Name Last Name       School\n0      James   Hammond     Business\n1       Mike     Smith          Law\n2      Sally    Brooks  Engineering\n```\n:::\n:::\n\n\nAs you see here, James Wilde and James Hammond don't match on both keys since they have different last names. So we would expect that an inner join doesn't include these individuals in the output, and only Sally Brooks will be retained.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\npd.merge(staff_df, student_df, how = 'inner', on = ['First Name', 'Last Name'])\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>First Name</th>\n      <th>Last Name</th>\n      <th>Role</th>\n      <th>School</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Sally</td>\n      <td>Brooks</td>\n      <td>Course liasion</td>\n      <td>Engineering</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we think of merging as **joining** \"horizontally\", meaning we join on similar values in a column found in two dataframes then **concatenating** is joining \"vertically\", meaning we put dataframes on top or at the bottom of each other.\n\nLet's understand this from an example. You have a dataset that tracks some information over the years. And each year's record is a separate CSV and every CSV of every year's record has the exactly same columns. What happens if you want to put all the data, from all years' record, together? You can concatenate them.\n\nLet's take a look at the US Department of Education College Scorecard data It has each US university's data on student completion, student debt, after-graduation income, etc. The data is stored in separate CSV's with each CSV containing a year's record Let's say we want the records from 2011 to 2013 we first create three dataframe, each containing one year's record. And, because the csv files we're working with are messy, I want to supress some of the jupyter warning messages and just tell read_csv to ignore bad lines, so I'm going to start the cell with a cell magic called %%capture:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n#df_2011 = pd.read_csv(\"../data/week3/MERGED2011_12_PP.csv\", error_bad_lines=False)\ndf_2012 = pd.read_csv(\"../data/week3/MERGED2012_13_PP.csv\", error_bad_lines=False)\ndf_2013 = pd.read_csv(\"../data/week3/MERGED2013_14_PP.csv\", error_bad_lines=False)\n```\n:::\n\n\nWe see that there is a whopping number of columns - more than 1900! We can calculate the length of each dataframe as well:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nprint(len(df_2012))\nprint(len(df_2013))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7793\n7804\n```\n:::\n:::\n\n\nThat's a bit surprising that the number of schools in the scorecard for 2011 is almost double that of the next two years. But let's not worry about that. Instead, let's just put all three dataframes in a list and call that list frames and pass the list into the concat() function Let's see what it looks like:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nframes = [df_2012, df_2013]\n#pd.concat(frames).head()\n```\n:::\n\n\nAs you can see, we have more observations in one dataframe and columns remain the same. If we scroll down to the bottom of the output, we see that there are a total of 30,832 rows after concatenating three dataframes.\n\nLet's add the number of rows of the three dataframes and see if the two numbers match:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint(pd.concat(frames).shape)\nprint(len(df_2012)+len(df_2013))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(15597, 1977)\n15597\n```\n:::\n:::\n\n\nThe two numbers match! Which means our concatenation is successful. But wait, now that all the data is concatenated together, we don't know what observations are from what year anymore! Actually the concat function has a parameter that solves such problem with the **keys parameter**, we can set an extra level of indices, we pass in a list of keys that we want to correspond to the dataframes into the keys parameter:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n#print(pd.concat(frames, keys=['2012','2013']).head())\n#print(pd.concat(frames, keys=['2012','2013']).tail())\n```\n:::\n\n\n",
    "supporting": [
      "5_pandas2_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}